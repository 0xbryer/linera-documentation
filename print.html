<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="The Linera Developer Manual">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">The Linera Developer Manual</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="getting_started/hello_linera.html"><strong aria-hidden="true">1.2.</strong> Hello, Linera</a></li></ol></li><li class="chapter-item expanded "><a href="core_concepts.html"><strong aria-hidden="true">2.</strong> The Linera Protocol</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core_concepts/overview.html"><strong aria-hidden="true">2.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="core_concepts/microchains.html"><strong aria-hidden="true">2.2.</strong> Microchains</a></li><li class="chapter-item expanded "><a href="core_concepts/wallets.html"><strong aria-hidden="true">2.3.</strong> Wallets</a></li><li class="chapter-item expanded "><a href="core_concepts/node_service.html"><strong aria-hidden="true">2.4.</strong> Node Service</a></li><li class="chapter-item expanded "><a href="core_concepts/applications.html"><strong aria-hidden="true">2.5.</strong> Applications</a></li></ol></li><li class="chapter-item expanded "><a href="sdk.html"><strong aria-hidden="true">3.</strong> Writing Linera Applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sdk/creating_a_project.html"><strong aria-hidden="true">3.1.</strong> Creating a Project</a></li><li class="chapter-item expanded "><a href="sdk/state.html"><strong aria-hidden="true">3.2.</strong> Creating the Application State</a></li><li class="chapter-item expanded "><a href="sdk/abi.html"><strong aria-hidden="true">3.3.</strong> Defining the ABI</a></li><li class="chapter-item expanded "><a href="sdk/contract.html"><strong aria-hidden="true">3.4.</strong> Writing the Contract Binary</a></li><li class="chapter-item expanded "><a href="sdk/service.html"><strong aria-hidden="true">3.5.</strong> Writing the Service Binary</a></li><li class="chapter-item expanded "><a href="sdk/deploy.html"><strong aria-hidden="true">3.6.</strong> Deploying the Application</a></li><li class="chapter-item expanded "><a href="sdk/messages.html"><strong aria-hidden="true">3.7.</strong> Cross-Chain Messages</a></li><li class="chapter-item expanded "><a href="sdk/composition.html"><strong aria-hidden="true">3.8.</strong> Calling other Applications</a></li><li class="chapter-item expanded "><a href="sdk/logging.html"><strong aria-hidden="true">3.9.</strong> Printing Logs from an Application</a></li><li class="chapter-item expanded "><a href="sdk/testing.html"><strong aria-hidden="true">3.10.</strong> Writing Tests</a></li></ol></li><li class="chapter-item expanded "><a href="advanced_topics.html"><strong aria-hidden="true">4.</strong> Advanced Topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced_topics/views.html"><strong aria-hidden="true">4.1.</strong> Views</a></li><li class="chapter-item expanded "><a href="advanced_topics/persistent_storage.html"><strong aria-hidden="true">4.2.</strong> Persistent Storage</a></li><li class="chapter-item expanded "><a href="advanced_topics/contract_finalize.html"><strong aria-hidden="true">4.3.</strong> Contract Finalization</a></li><li class="chapter-item expanded "><a href="advanced_topics/validators.html"><strong aria-hidden="true">4.4.</strong> Validators</a></li><li class="chapter-item expanded "><a href="advanced_topics/block_creation.html"><strong aria-hidden="true">4.5.</strong> Creating New Blocks</a></li><li class="chapter-item expanded "><a href="advanced_topics/assets.html"><strong aria-hidden="true">4.6.</strong> Applications that Handle Assets</a></li></ol></li><li class="chapter-item expanded "><a href="appendix/glossary.html"><strong aria-hidden="true">5.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/glossary.html"><strong aria-hidden="true">5.1.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="videos.html"><strong aria-hidden="true">5.2.</strong> Videos</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="images/Linera-Header_1920x284px.svg" alt="The Linera banner" /></p>
<h1 id="the-linera-developer-manual"><a class="header" href="#the-linera-developer-manual">The Linera Developer Manual</a></h1>
<p>Welcome to the developer manual of Linera, a decentralized protocol designed for
<strong>highly scalable, low-latency Web3 applications</strong>.</p>
<p>This documentation is intended for developers who wish to learn more about
Linera and its programming model by prototyping applications on top of the
Linera Rust SDK.</p>
<blockquote>
<p><strong>NEW: Publish and test your Web3 application on the Linera Devnet!</strong></p>
<p>Install
<a href="getting_started/installation.html#installing-from-cratesio">the Linera CLI tool</a>
then follow the instructions on
<a href="getting_started/hello_linera.html#using-the-devnet">this page</a> to claim a
microchain and publish your first application on the current Devnet.</p>
</blockquote>
<p>To join our community and get involved in the development of the Linera
ecosystem, check out our
<a href="https://github.com/linera-io/linera-protocol">GitHub repository</a>, our
<a href="https://linera.io">website</a>, and find us on social media channels such as
<a href="https://www.youtube.com/@linera_io">youtube</a>,
<a href="https://twitter.com/linera_io">twitter</a>,
<a href="https://t.me/linera_official">telegram</a>, and
<a href="https://discord.gg/linera">discord</a>.</p>
<p>Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>In this section, we will cover the necessary steps to install the Linera
toolchain and give a short example to get started with the Linera SDK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Let's start with the installation of the Linera development tools.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The Linera toolchain consist of two crates:</p>
<ul>
<li>
<p><code>linera-sdk</code> is the main library to program Linera applications in Rust. It
also includes the Wasm test runner binary <code>linera-wasm-test-runner</code>.</p>
</li>
<li>
<p><code>linera-service</code> defines a number of binaries, including:</p>
<ul>
<li><code>linera</code> -- the main client tool, used to operate development wallets,</li>
<li><code>linera-proxy</code> -- the proxy service, acting as a public entrypoint for each
validator,</li>
<li><code>linera-server</code> -- the service run by each worker of a validator, hidden
behind the proxy.</li>
</ul>
</li>
</ul>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>The operating systems currently supported by the Linera toolchain can be
summarized as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Linux x86 64-bit</th><th>Mac OS (M1 / M2)</th><th>Mac OS (x86)</th><th>Windows</th></tr></thead><tbody>
<tr><td>✓ Main platform</td><td>✓ Working</td><td>✓ Working</td><td>Untested</td></tr>
</tbody></table>
</div>
<p>The main prerequisites to install the Linera toolchain are Rust, Wasm, and
Protoc. They can be installed as follows on Linux:</p>
<ul>
<li>
<p>Rust and Wasm</p>
<ul>
<li><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></li>
<li><code>rustup target add wasm32-unknown-unknown</code></li>
</ul>
</li>
<li>
<p>Protoc</p>
<ul>
<li><code>curl -LO https://github.com/protocolbuffers/protobuf/releases/download/v21.11/protoc-21.11-linux-x86_64.zip</code></li>
<li><code>unzip protoc-21.11-linux-x86_64.zip -d $HOME/.local</code></li>
<li>If <code>~/.local</code> is not in your path, add it:
<code>export PATH="$PATH:$HOME/.local/bin"</code></li>
</ul>
</li>
<li>
<p>On certain Linux distributions, you may have to install development packages
such as <code>g++</code>, <code>libclang-dev</code> and <code>libssl-dev</code>.</p>
</li>
</ul>
<p>For MacOS support and for additional requirements needed to test the Linera
protocol itself, see the installation section on
<a href="https://github.com/linera-io/linera-protocol/blob/main/INSTALL.md">GitHub</a>.</p>
<p>This manual was tested with the following Rust toolchain:</p>
<pre><code class="language-text">[toolchain]
channel = "1.75.0"
components = [ "clippy", "rustfmt", "rust-src" ]
targets = [ "wasm32-unknown-unknown" ]
profile = "minimal"
</code></pre>
<h2 id="installing-from-cratesio"><a class="header" href="#installing-from-cratesio">Installing from crates.io</a></h2>
<p>You may install the Linera binaries with</p>
<pre><code class="language-bash">cargo install linera-sdk@0.10.1
cargo install linera-service@0.10.1
</code></pre>
<p>and use <code>linera-sdk</code> as a library for Linera Wasm applications:</p>
<pre><code class="language-bash">cargo add linera-sdk@0.10.1
</code></pre>
<p>The version number <code>0.10.1</code> corresponds to the
current Devnet of Linera and may change frequently.</p>
<h2 id="installing-from-github"><a class="header" href="#installing-from-github">Installing from GitHub</a></h2>
<p>Download the source from <a href="https://github.com/linera-io/linera-protocol">GitHub</a>:</p>
<pre><code class="language-bash">git clone https://github.com/linera-io/linera-protocol.git
cd linera-protocol
git checkout -t origin/devnet_2024_03_26  # Current release branch
</code></pre>
<p>To install the Linera toolchain locally from source, you may run:</p>
<pre><code class="language-bash">cargo install --path linera-sdk
cargo install --path linera-service
</code></pre>
<p>Alternatively, for developing and debugging, you may instead use the binaries
compiled in debug mode, e.g. using <code>export PATH="$PWD/target/debug:$PATH"</code>.</p>
<p>This manual was tested against the following commit of the
<a href="https://github.com/linera-io/linera-protocol">repository</a>:</p>
<pre><code class="language-text">756bc35d0747181af025f70802b782bf1387abba
</code></pre>
<h2 id="bash-helper-optional"><a class="header" href="#bash-helper-optional">Bash helper (optional)</a></h2>
<p>Consider adding the output of <code>linera net helper</code> to your <code>~/.bash_profile</code> to
help with <a href="getting_started/../core_concepts/wallets.html#automation-in-bash">automation</a>.</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting help</a></h2>
<p>If installation fails, reach out to the team (e.g. on
<a href="https://discord.gg/linera">Discord</a>) to help troubleshoot your issue or
<a href="https://github.com/linera-io/linera-protocol/issues/new">create an issue</a> on
GitHub.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-linera"><a class="header" href="#hello-linera">Hello, Linera</a></h1>
<p>This section is about interacting with the Devnet, running a local development
network, then compiling and deploying your first application from scratch.</p>
<p>By the end of this section, you'll have a
<a href="getting_started/../core_concepts/microchains.html">microchain</a> on the Devnet and/or on your local
network, and a working application that can be queried using GraphQL.</p>
<h2 id="using-the-devnet"><a class="header" href="#using-the-devnet">Using the Devnet</a></h2>
<p>The Linera Devnet is a deployment of the Linera protocol that's useful for
developers. It should not be considered stable, and can be restarted from a
clean slate and new genesis at any time.</p>
<p>To interact with the Devnet, some tokens are needed. A Faucet service is
available to create new microchains and obtain some test tokens. To do so, this
must be configured when initializing the wallet:</p>
<pre><code class="language-bash">linera wallet init --with-new-chain --faucet https://faucet.devnet-2024-03-26.linera.net
</code></pre>
<p>This creates a new microchain on Devnet with some initial test tokens, and the
chain is automatically added to the newly instantiated wallet.</p>
<blockquote>
<p>Make sure to use a Linera toolchain
<a href="getting_started/installation.html#installing-from-cratesio">compatible with the current Devnet</a>.</p>
</blockquote>
<h2 id="starting-a-local-test-network"><a class="header" href="#starting-a-local-test-network">Starting a Local Test Network</a></h2>
<p>Another option is to start your own local development network. A development
network consists of a number of <a href="getting_started/../advanced_topics/validators.html">validators</a>,
each of which consist of an ingress proxy (aka. a "load balancer") and a number
of workers (aka. "physical shards").</p>
<p>To start a local network, run the following command:</p>
<pre><code class="language-bash">linera net up
</code></pre>
<p>This will start a validator with the default number of shards and create a
temporary directory storing the entire network state.</p>
<p>This will set up a number of initial chains and create an initial wallet to
operate them.</p>
<h3 id="using-the-initial-test-wallet"><a class="header" href="#using-the-initial-test-wallet">Using the Initial Test Wallet</a></h3>
<p><code>linera net up</code> prints Bash statements on its standard output to help you
configure your terminal to use the initial wallet of the new test network, for
instance:</p>
<pre><code class="language-bash">export LINERA_WALLET="/var/folders/3d/406tbklx3zx2p3_hzzpfqdbc0000gn/T/.tmpvJ6lJI/wallet.json"
export LINERA_STORAGE="rocksdb:/var/folders/3d/406tbklx3zx2p3_hzzpfqdbc0000gn/T/.tmpvJ6lJI/linera.db"
</code></pre>
<p>This wallet is only valid for the lifetime of a single network. Every time a
local network is restarted, the wallet needs to be reconfigured.</p>
<h2 id="interacting-with-the-network"><a class="header" href="#interacting-with-the-network">Interacting with the Network</a></h2>
<blockquote>
<p>In the following examples, we assume that either the wallet was initialized to
interact with the Devnet or the variables <code>LINERA_WALLET</code> and <code>LINERA_STORAGE</code>
are both set and point to the initial wallet of the running local network.</p>
</blockquote>
<p>The main way of interacting with the network and deploying applications is using
the <code>linera</code> client.</p>
<p>To check that the network is working, you can synchronize your
<a href="getting_started/../core_concepts/wallets.html">default chain</a> with the rest of the network and
display the chain balance as follows:</p>
<pre><code class="language-bash">linera sync
linera query-balance
</code></pre>
<p>You should see an output number, e.g. <code>10</code>.</p>
<h2 id="building-an-example-application"><a class="header" href="#building-an-example-application">Building an Example Application</a></h2>
<p>Applications running on Linera are <a href="https://webassembly.org/">Wasm</a> bytecode.
Each validator and client has a built-in Wasm virtual machine (VM) which can
execute bytecode.</p>
<p>Let's build the <code>counter</code> application from the <code>examples/</code> subdirectory:</p>
<pre><code class="language-bash">cd examples/counter &amp;&amp; cargo build --release
</code></pre>
<blockquote>
<p>Note: This will automatically build Wasm, not native code, thanks to the
configuration file <code>examples/.cargo/config.toml</code>.</p>
</blockquote>
<h2 id="publishing-your-application"><a class="header" href="#publishing-your-application">Publishing your Application</a></h2>
<p>You can publish the bytecode and create an application using it on your local
network using the <code>linera</code> client's <code>publish-and-create</code> command and provide:</p>
<ol>
<li>The location of the contract bytecode</li>
<li>The location of the service bytecode</li>
<li>The JSON encoded initialization arguments</li>
</ol>
<pre><code class="language-bash">linera publish-and-create \
  ../target/wasm32-unknown-unknown/release/counter_{contract,service}.wasm \
  --json-argument "42"
</code></pre>
<p>Congratulations! You've published your first application on Linera!</p>
<h2 id="querying-your-application"><a class="header" href="#querying-your-application">Querying your Application</a></h2>
<p>Now let's query your application to get the current counter value. To do that,
we need to use the client running in
<a href="getting_started/../core_concepts/node_service.html"><em>service</em> mode</a>. This will expose a bunch of
APIs locally which we can use to interact with applications on the network.</p>
<pre><code class="language-bash">linera service
</code></pre>
<!-- TODO: add graphiql image here -->
<p>Navigate to <code>http://localhost:8080</code> in your browser to access the GraphiQL, the
<a href="https://graphql.org">GraphQL</a> IDE. We'll look at this in more detail in a
<a href="getting_started/../core_concepts/node_service.html#graphiql-ide">later section</a>; for now, list
the applications deployed on your default chain e476… by running:</p>
<pre><code class="language-gql">query {
  applications(
    chainId: "e476187f6ddfeb9d588c7b45d3df334d5501d6499b3f9ad5595cae86cce16a65"
  ) {
    id
    description
    link
  }
}
</code></pre>
<p>Since we've only deployed one application, the results returned have a single
entry.</p>
<p>At the bottom of the returned JSON there is a field <code>link</code>. To interact with
your application copy and paste the link into a new browser tab.</p>
<p>Finally, to query the counter value, run:</p>
<pre><code class="language-gql">query {
  value
}
</code></pre>
<p>This will return a value of <code>42</code>, which is the initialization argument we
specified when deploying our application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-linera-protocol"><a class="header" href="#the-linera-protocol">The Linera Protocol</a></h1>
<p>We now describe the main concepts of the Linera protocol in more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>Linera is a decentralized infrastructure optimized for Web3 applications that
require guaranteed performance for an unlimited number of active users.</p>
<p>The core idea of the Linera protocol is to run many lightweight blockchains,
called <strong>microchains</strong>, in parallel in a single set of validators.</p>
<h2 id="how-does-it-work"><a class="header" href="#how-does-it-work">How does it work?</a></h2>
<p>In Linera, user wallets operate their own microchains. The owner of a chain
chooses when to add new blocks to the chain and what goes inside the blocks.
Such chains with a single user are called <strong>user chains</strong>.</p>
<p>Users may add new blocks to their chains in order to process <strong>incoming
messages</strong> from other chains or to execute secure <strong>operations</strong> on their
accounts, for instance to transfer assets to another user.</p>
<p>Importantly, validators ensure that all new blocks are <strong>valid</strong>. For instance,
transfer operations must originate from accounts with sufficient funds; and
incoming messages must have been actually sent from another chain. Blocks are
verified by validators in the same way for every chain.</p>
<p>A Linera <strong>application</strong> is a Wasm program that defines its own state and
operations. Users can publish bytecode and initialize an application on one
chain, and it will be automatically deployed to all chains where it is needed,
with a separate state on each chain.</p>
<p>To ensure coordination across chains, an application may rely on asynchronous
<strong>cross-chain messages</strong>. Message payloads are application-specific and opaque
to the rest of the system.</p>
<pre><code class="language-ignore">                               ┌───┐     ┌───┐     ┌───┐
                       Chain A │   ├────►│   ├────►│   │
                               └───┘     └───┘     └───┘
                                                     ▲
                                           ┌─────────┘
                                           │
                               ┌───┐     ┌─┴─┐     ┌───┐
                       Chain B │   ├────►│   ├────►│   │
                               └───┘     └─┬─┘     └───┘
                                           │         ▲
                                           │         │
                                           ▼         │
                               ┌───┐     ┌───┐     ┌─┴─┐
                       Chain C │   ├────►│   ├────►│   │
                               └───┘     └───┘     └───┘
</code></pre>
<p>The number of applications present on a single chain is not limited. On the same
chain, applications are <strong>composed</strong> as usual using synchronous calls.</p>
<p>The current Linera SDK uses <strong>Rust</strong> as a source language to create Wasm
applications. It relies on the normal Rust toolchains so that Rust programmers
can work in their preferred environments.</p>
<h2 id="how-does-linera-compare-to-existing-multi-chain-infrastructure"><a class="header" href="#how-does-linera-compare-to-existing-multi-chain-infrastructure">How does Linera compare to existing multi-chain infrastructure?</a></h2>
<p>Linera is the first infrastructure designed to support many chains in parallel,
and notably an arbitrary number of <strong>user chains</strong> meant to be operated by user
wallets.</p>
<p>In traditional multi-chain infrastructures, each chain usually runs a full
blockchain protocol in a separate set of validators. Creating a new chain or
exchanging messages between chains is expensive. As a result, the total number
of chains is generally limited. Some chains may be specialized to a given use
case: these are called "app chains".</p>
<p>In contrast, Linera is optimized for a large number of user chains:</p>
<ul>
<li>
<p>Users only create blocks in their chain when needed;</p>
</li>
<li>
<p>Creating a microchain does not require onboarding validators;</p>
</li>
<li>
<p>All chains have the same level of security;</p>
</li>
<li>
<p>Microchains communicate efficiently using the internal networks of validators;</p>
</li>
<li>
<p>Validators are internally sharded (like a regular web service) and may adjust
their capacity elastically by adding or removing internal workers.</p>
</li>
</ul>
<blockquote>
<p>Besides user chains, the <a href="https://linera.io/whitepaper">Linera protocol</a> is
designed to support other types of microchains, called "permissioned" and
"public" chains. Public chains are operated by validators. In this regard,
they are similar to classical blockchains. Permissioned chains are meant to be
used for temporary interactions between users, such as atomic swaps.</p>
</blockquote>
<h2 id="why-build-on-top-of-linera"><a class="header" href="#why-build-on-top-of-linera">Why build on top of Linera?</a></h2>
<p>We believe that many high-value use cases are currently out of reach of existing
Web3 infrastructures because of the challenges of serving <strong>many active users</strong>
simultaneously without degrading user experience (unpredictable fees, latency,
etc).</p>
<p>Examples of applications that require processing time-sensitive transactions
created by many simultaneous users include:</p>
<ul>
<li>
<p>real-time micro-payments and micro-rewards,</p>
</li>
<li>
<p>social data feeds,</p>
</li>
<li>
<p>real-time auction systems,</p>
</li>
<li>
<p>turn-based games,</p>
</li>
<li>
<p>version control systems for software, data pipelines, or AI training
pipelines.</p>
</li>
</ul>
<p>Lightweight user chains are instrumental in providing elastic scalability but
they have other benefits as well. Because user chains have fewer blocks than
traditional blockchains, in Linera, the full-nodes of user chains will be
embedded into the users' wallets, typically deployed as a browser extension.</p>
<p>This means that Web UIs connected to a wallet will be able to query the state of
the user chain directly (no API provider, no light client) using familiar
frameworks (React/GraphQL). Furthermore, wallets will be able to leverage the
full node as well for security purposes, including to display meaningful
confirmation messages to users.</p>
<h2 id="what-is-the-current-state-of-the-development-of-linera"><a class="header" href="#what-is-the-current-state-of-the-development-of-linera">What is the current state of the development of Linera?</a></h2>
<p>The
<a href="https://github.com/linera-io/linera-protocol">reference open-source implementation</a>
of Linera is under active development. It already includes a Web3 SDK with the
necessary features to prototype simple Web3 applications and test them locally
on the same machine. Notably, Web UIs (possibly reactive) can already be built
on top of Wasm-embedded GraphQL services, and tested locally in the browser.</p>
<p>The main limitations of our current Web3 SDK include:</p>
<ul>
<li>
<p>Web UIs need to query a local HTTP service acting as a wallet. This setup is
meant to be temporary and for testing only: in the future, web UIs will
securely connect to a Wallet installed as a browser extension, as usual.</p>
</li>
<li>
<p>Only user chains are currently available for testing and documented in this
manual. Support for other types of chain (called "public" and "permissioned")
will be added later.</p>
</li>
</ul>
<p>The main development workstreams of Linera, beyond its SDK, can be broken down
as follows.</p>
<h3 id="core-protocol"><a class="header" href="#core-protocol">Core Protocol</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
User chains</li>
<li><input disabled="" type="checkbox" checked=""/>
Permissioned chain (core protocol only)</li>
<li><input disabled="" type="checkbox" checked=""/>
Cross-chain messages</li>
<li><input disabled="" type="checkbox" checked=""/>
Cross-chain pub/sub channels (initial version)</li>
<li><input disabled="" type="checkbox" checked=""/>
Bytecode publishing</li>
<li><input disabled="" type="checkbox" checked=""/>
Application creation</li>
<li><input disabled="" type="checkbox" checked=""/>
Reconfigurations of validators</li>
<li><input disabled="" type="checkbox" checked=""/>
Initial support for gas fees</li>
<li><input disabled="" type="checkbox" checked=""/>
Initial support for storage fees and storage limits</li>
<li><input disabled="" type="checkbox" checked=""/>
External services to help users create their first chain</li>
<li><input disabled="" type="checkbox"/>
Permissioned chains (adding operation access control, demo of atomic
swaps, etc)</li>
<li><input disabled="" type="checkbox"/>
Public chains (adding leader election, inbox constraints, etc)</li>
<li><input disabled="" type="checkbox"/>
Support for easy onboarding of user chains into a new application
(removing the need to accept requests)</li>
<li><input disabled="" type="checkbox"/>
Improved pub/sub channels (removing the need to accept subscriptions)</li>
<li><input disabled="" type="checkbox"/>
Blob storage for applications (generalizing bytecode storage)</li>
<li><input disabled="" type="checkbox"/>
Support for archiving chains</li>
<li><input disabled="" type="checkbox"/>
Wallet-friendly chain clients (compile to Wasm/JS, do not maintain
execution states for other chains)</li>
<li><input disabled="" type="checkbox"/>
General tokenomics and incentives for all stakeholders</li>
<li><input disabled="" type="checkbox"/>
Governance on the admin chain (e.g. DPoS, onboarding of validators)</li>
<li><input disabled="" type="checkbox"/>
Auditing procedures</li>
</ul>
<h3 id="wasm-vm-integration"><a class="header" href="#wasm-vm-integration">Wasm VM integration</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Support for the Wasmer VM</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for the Wasmtime VM (experimental)</li>
<li><input disabled="" type="checkbox" checked=""/>
Test gas metering and deterministic execution across VMs</li>
<li><input disabled="" type="checkbox" checked=""/>
Composing Wasm applications on the same chain (initial version)</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for non-blocking (yet deterministic) calls to storage</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for read-only GraphQL services in Wasm</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for mocked system APIs (initial version)</li>
<li><input disabled="" type="checkbox" checked=""/>
More efficient cross-application calls</li>
<li><input disabled="" type="checkbox"/>
Improve host/guest stub generation to make mocks easier (currently
wit-bindgen)</li>
<li><input disabled="" type="checkbox"/>
Compile user full node to Wasm/JS</li>
</ul>
<h3 id="storage"><a class="header" href="#storage">Storage</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Object management library ("linera-views") on top of Key-Value store
abstraction</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for Rocksdb</li>
<li><input disabled="" type="checkbox" checked=""/>
Experimental support for DynamoDb</li>
<li><input disabled="" type="checkbox" checked=""/>
Initial derive macros for GraphQL</li>
<li><input disabled="" type="checkbox" checked=""/>
Initial support for ScyllaDb</li>
<li><input disabled="" type="checkbox" checked=""/>
Make library fully extensible by users (requires better GraphQL macros)</li>
<li><input disabled="" type="checkbox"/>
Performance benchmarks and improvements (including faster state hashing)</li>
<li><input disabled="" type="checkbox"/>
Production-grade support for the chosen main database</li>
<li><input disabled="" type="checkbox"/>
Support global object locks (needed for dynamic sharding)</li>
<li><input disabled="" type="checkbox"/>
Tooling for debugging</li>
<li><input disabled="" type="checkbox"/>
Make the storage library easy to use outside of Linera</li>
</ul>
<h3 id="validator-infrastructure"><a class="header" href="#validator-infrastructure">Validator Infrastructure</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Simple TCP/UDP networking (used for benchmarks only)</li>
<li><input disabled="" type="checkbox" checked=""/>
GRPC networking</li>
<li><input disabled="" type="checkbox" checked=""/>
Basic frontend (aka. proxy) supporting fixed internal shards</li>
<li><input disabled="" type="checkbox" checked=""/>
Observability</li>
<li><input disabled="" type="checkbox" checked=""/>
Initial kubernetes support in CI</li>
<li><input disabled="" type="checkbox" checked=""/>
Initial deployment using a cloud provider</li>
<li><input disabled="" type="checkbox"/>
New frontend to support dynamic shard assignment</li>
<li><input disabled="" type="checkbox"/>
Cloud integration to demonstrate elastic scaling</li>
</ul>
<h3 id="web3-sdk"><a class="header" href="#web3-sdk">Web3 SDK</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Initial traits for contract and service interfaces</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for unit testing</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for integration testing</li>
<li><input disabled="" type="checkbox" checked=""/>
Local GraphQL service to query and browse system state</li>
<li><input disabled="" type="checkbox" checked=""/>
Local GraphQL service to query and browse application states</li>
<li><input disabled="" type="checkbox" checked=""/>
Use GraphQL mutations to execute operations and create blocks</li>
<li><input disabled="" type="checkbox" checked=""/>
Initial ABIs for contract and service interfaces</li>
<li><input disabled="" type="checkbox"/>
Allowing message sender to pay for message execution fees</li>
<li><input disabled="" type="checkbox"/>
Bindings to use native cryptographic primitives from Wasm</li>
<li><input disabled="" type="checkbox"/>
Allowing applications to pay for user fees</li>
<li><input disabled="" type="checkbox"/>
Allowing applications to use permissioned chains and public chains</li>
<li><input disabled="" type="checkbox"/>
Wallet as a browser extension (no VM)</li>
<li><input disabled="" type="checkbox"/>
Wallet as a browser extension (with Wasm VM)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microchains"><a class="header" href="#microchains">Microchains</a></h1>
<p>This section provides an introduction to microchains, the main building block of
the Linera Protocol. For a more formal treatment refer to the
<a href="https://linera.io/whitepaper">whitepaper</a>.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>A <strong>microchain</strong> is a chain of blocks describing successive changes to a shared
state. We will use the terms <em>chain</em> and <em>microchain</em> interchangeably. Linera
microchains are similar to the familiar notion of blockchain, with the following
important specificities:</p>
<ul>
<li>
<p>An arbitrary number of microchains can coexist in a Linera network, all
sharing the same set of validators and the same level of security. Creating a
new microchain only takes one transaction on an existing chain.</p>
</li>
<li>
<p>The task of proposing new blocks in a microchain can be assumed either by
validators or by end users (or rather their wallets) depending on the
configuration of a chain. Specifically, microchains can be <em>single-owner</em>,
<em>permissioned</em>, or <em>public</em>, depending on who is authorized to propose blocks.</p>
</li>
</ul>
<h2 id="cross-chain-messaging"><a class="header" href="#cross-chain-messaging">Cross-Chain Messaging</a></h2>
<p>In traditional networks with a single blockchain, every transaction can access
the entire execution state. This is not the case in Linera where the state of a
microchain is only affected by its own blocks.</p>
<p>Cross-chain messaging is a way for different microchains to communicate with
each other asynchronously. This method allows applications and data to be
distributed across multiple chains for better scalability. When an application
on one chain sends a message to another chain, a cross-chain request is created.
These requests are implemented using remote procedure calls (RPCs) within the
validators' internal network, ensuring that each request is executed only once.</p>
<p>Instead of immediately modifying the target chain, messages are placed first in
the target chain's <strong>inbox</strong>. When an owner of the target chain creates its next
block in the future, they may reference a selection of messages taken from the
current inbox in the new block. This executes the selected messages and applies
their messages to the chain state.</p>
<p>Below is an example set of chains sending asynchronous messages to each other
over consecutive blocks.</p>
<pre><code class="language-ignore">                               ┌───┐     ┌───┐     ┌───┐
                       Chain A │   ├────►│   ├────►│   │
                               └───┘     └───┘     └───┘
                                                     ▲
                                           ┌─────────┘
                                           │
                               ┌───┐     ┌─┴─┐     ┌───┐
                       Chain B │   ├────►│   ├────►│   │
                               └───┘     └─┬─┘     └───┘
                                           │         ▲
                                           │         │
                                           ▼         │
                               ┌───┐     ┌───┐     ┌─┴─┐
                       Chain C │   ├────►│   ├────►│   │
                               └───┘     └───┘     └───┘
</code></pre>
<p>The Linera protocol allows receivers to discard messages but not to change the
ordering of selected messages inside the communication queue between two chains.
If a selected message fails to execute, it is skipped during the execution of
the receiver's block. The current implementation of the Linera client always
selects as many messages as possible from inboxes, and never discards messages.</p>
<h2 id="chain-ownership-semantics"><a class="header" href="#chain-ownership-semantics">Chain Ownership Semantics</a></h2>
<p>Only single-owner chains are currently supported in the Linera SDK. However,
microchains can create new microchains for other users, and control of a chain
can be transferred to another user by changing the owner ID. A chain is
permanently deactivated when its owner ID is set to <code>None</code>.</p>
<p>For more detail and examples on how to open and close chains, see the wallet
section on <a href="core_concepts/wallets.html#opening-a-chain">chain management</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallets"><a class="header" href="#wallets">Wallets</a></h1>
<p>As in traditional blockchains, Linera wallets are in charge of holding user
private keys. However, instead of signing transactions, Linera wallets are meant
to sign blocks and propose them to extend the chains owned by their users.</p>
<p>In practice, wallets include a node which tracks a subset of Linera chains. We
will see in the <a href="core_concepts/node_service.html">next section</a> how a Linera wallet can run a
GraphQL service to expose the state of its chains to web frontends.</p>
<blockquote>
<p>The command-line tool <code>linera</code> is the main way for developers to interact with
a Linera network and manage the user wallets present locally on the system.</p>
</blockquote>
<p>Note that this command-line tool is intended mainly for development purposes.
Our goal is that end users eventually manage their wallets in a
<a href="core_concepts/overview.html#web3-sdk">browser extension</a>.</p>
<h2 id="selecting-a-wallet"><a class="header" href="#selecting-a-wallet">Selecting a Wallet</a></h2>
<p>The private state of a wallet is conventionally stored in a file <code>wallet.json</code>,
while the state of its node is stored in a file <code>linera.db</code>.</p>
<p>To switch between wallets, you may use the <code>--wallet</code> and <code>--storage</code> options of
the <code>linera</code> tool, e.g. as in
<code>linera --wallet wallet2.json --storage rocksdb:linera2.db</code>.</p>
<p>You may also define the environment variables <code>LINERA_STORAGE</code> and
<code>LINERA_WALLET</code> to the same effect. E.g. <code>LINERA_STORAGE=$PWD/wallet2.json</code> and
<code>LINERA_WALLET=$PWD/wallet2.json</code>.</p>
<p>Finally, if <code>LINERA_STORAGE_$I</code> and <code>LINERA_WALLET_$I</code> are defined for some
number <code>I</code>, you may call <code>linera --with-wallet $I</code> (or <code>linera -w $I</code> for
short).</p>
<h2 id="chain-management"><a class="header" href="#chain-management">Chain Management</a></h2>
<h3 id="listing-chains"><a class="header" href="#listing-chains">Listing Chains</a></h3>
<p>To list the chains present in your wallet, you may use the command <code>show</code>:</p>
<pre><code class="language-bash">linera wallet show
╭──────────────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────────────────────────────────────╮
│ Chain ID                                                         ┆ Latest Block                                                                         │
╞══════════════════════════════════════════════════════════════════╪══════════════════════════════════════════════════════════════════════════════════════╡
│ 668774d6f49d0426f610ad0bfa22d2a06f5f5b7b5c045b84a26286ba6bce93b4 ┆ Public Key:         3812c2bf764e905a3b130a754e7709fe2fc725c0ee346cb15d6d261e4f30b8f1 │
│                                                                  ┆ Owner:              c9a538585667076981abfe99902bac9f4be93714854281b652d07bb6d444cb76 │
│                                                                  ┆ Block Hash:         -                                                                │
│                                                                  ┆ Timestamp:          2023-04-10 13:52:20.820840                                       │
│                                                                  ┆ Next Block Height:  0                                                                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 91c7b394ef500cd000e365807b770d5b76a6e8c9c2f2af8e58c205e521b5f646 ┆ Public Key:         29c19718a26cb0d5c1d28102a2836442f53e3184f33b619ff653447280ccba1a │
│                                                                  ┆ Owner:              efe0f66451f2f15c33a409dfecdf76941cf1e215c5482d632c84a2573a1474e8 │
│                                                                  ┆ Block Hash:         51605cad3f6a210183ac99f7f6ef507d0870d0c3a3858058034cfc0e3e541c13 │
│                                                                  ┆ Timestamp:          2023-04-10 13:52:21.885221                                       │
│                                                                  ┆ Next Block Height:  1                                                                │
╰──────────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────────────────────╯

</code></pre>
<p>Each row represents a chain present in the wallet. On the left is the unique
identifier on the chain, and on the right is metadata for that chain associated
with the latest block.</p>
<h3 id="default-chain"><a class="header" href="#default-chain">Default Chain</a></h3>
<p>Each wallet has a default chain that all commands apply to unless you specify
another <code>--chain</code> on the command line.</p>
<p>The default chain is set initially, when the first chain is added to the wallet.
You can check the default chain for your wallet by running:</p>
<pre><code class="language-bash">linera wallet show
</code></pre>
<p>The Chain ID which is in green text instead of white text is your default chain.</p>
<p>To change the default chain for your wallet, user the <code>set-default</code> command:</p>
<pre><code class="language-bash">linera wallet set-default &lt;chain-id&gt;
</code></pre>
<h3 id="opening-a-chain"><a class="header" href="#opening-a-chain">Opening a Chain</a></h3>
<p>The Linera protocol defines semantics for how new chains are created, we call
this "opening a chain". A chain cannot be opened in a vacuum, it needs to be
created by an existing chain on the network.</p>
<h4 id="open-a-chain-for-your-own-wallet"><a class="header" href="#open-a-chain-for-your-own-wallet">Open a Chain for Your Own Wallet</a></h4>
<p>To open a chain for your own wallet, you can use the <code>open-chain</code> command:</p>
<pre><code class="language-bash">linera open-chain
</code></pre>
<p>This will create a new chain (using the wallet's default chain) and add it to
the wallet. Use the <code>wallet show</code> command to see your existing chains.</p>
<h4 id="open-a-chain-for-another-wallet"><a class="header" href="#open-a-chain-for-another-wallet">Open a Chain for Another Wallet</a></h4>
<p>Opening a chain for another <code>wallet</code> requires an extra two steps. Let's
initialize a second wallet:</p>
<pre><code class="language-bash">linera --wallet wallet2.json --storage rocksdb:linera2.db wallet init --genesis target/debug/genesis.json
</code></pre>
<p>First <code>wallet2</code> must create an unassigned keypair. The public part of that
keypair is then sent to the <code>wallet</code> who is the chain creator.</p>
<pre><code class="language-bash">linera --wallet wallet2.json keygen
6443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c914088888 # this is the public key for the unassigned keypair
</code></pre>
<p>Next, using the public key, <code>wallet</code> can open a chain for <code>wallet2</code>.</p>
<pre><code class="language-bash">linera open-chain --to-public-key 6443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c914088888
e476187f6ddfeb9d588c7b45d3df334d5501d6499b3f9ad5595cae86cce16a65010000000000000000000000
fc9384defb0bcd8f6e206ffda32599e24ba715f45ec88d4ac81ec47eb84fa111
</code></pre>
<p>The first line is the message ID specifying the cross-chain message that creates
the new chain. The second line is the new chain's ID.</p>
<p>Finally, to add the chain to <code>wallet2</code> for the given unassigned key we use the
<code>assign</code> command:</p>
<pre><code class="language-bash"> linera --wallet wallet2.json assign --key 6443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c914088888 --message-id e476187f6ddfeb9d588c7b45d3df334d5501d6499b3f9ad5595cae86cce16a65010000000000000000000000
</code></pre>
<h2 id="setting-up-extra-wallets-automatically-with-linera-net-up"><a class="header" href="#setting-up-extra-wallets-automatically-with-linera-net-up">Setting up Extra Wallets Automatically with <code>linera net up</code></a></h2>
<p>For testing, rather than using <code>linera open-chain</code> and <code>linera assign</code> as above,
it is often more convenient to pass the option <code>--extra-wallets N</code> to
<code>linera net up</code>.</p>
<p>This option will create create <code>N</code> additional user wallets and output Bash
commands to define the environment variables <code>LINERA_{WALLET,STORAGE}_$I</code> where
<code>I</code> ranges over <code>0..=N</code> (<code>I=0</code> being the wallet for the initial chains).</p>
<p>Once all the environment variables are defined, you may switch between wallets
using <code>linera --with-wallet I</code> or <code>linera -w I</code> for short.</p>
<h2 id="automation-in-bash"><a class="header" href="#automation-in-bash">Automation in Bash</a></h2>
<p>To automate the process of setting the variables <code>LINERA_WALLET*</code> and
<code>LINERA_STORAGE*</code> after creating a local test network in a shell, we provide a
Bash helper function <code>linera_spawn_and_read_wallet_variables</code>.</p>
<p>To define the function <code>linera_spawn_and_read_wallet_variables</code> in your shell,
run <code>source /dev/stdin &lt;&lt;&lt;"$(linera net helper 2&gt;/dev/null)"</code>. You may also add
the output of <code>linera net helper</code> to your <code>~/.bash_profile</code> for future sessions.</p>
<p>Once the function is defined, call
<code>linera_spawn_and_read_wallet_variables linera net up</code> instead of
<code>linera net up</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-service"><a class="header" href="#node-service">Node Service</a></h1>
<p>So far we've seen how to use the Linera client treating it as a binary in your
terminal. However, the client also acts as a node which:</p>
<ol>
<li>Executes blocks</li>
<li>Exposes an GraphQL API and IDE for dynamically interacting with applications
and the system</li>
<li>Listens for notifications from validators and automatically updates local
chains.</li>
</ol>
<p>To interact with the node service, run <code>linera</code> in <code>service</code> mode:</p>
<pre><code class="language-bash">linera service
</code></pre>
<p>This will run the node service on port 8080 by default (this can be overridden
using the <code>--port</code> flag).</p>
<h2 id="a-note-on-graphql"><a class="header" href="#a-note-on-graphql">A Note on GraphQL</a></h2>
<p>Linera uses GraphQL as the query language for interfacing with different parts
of the system. GraphQL enables clients to craft queries such that they receive
exactly what they want and nothing more.</p>
<p>GraphQL is used extensively during application development, especially to query
the state of an application from a front-end for example.</p>
<p>To learn more about GraphQL check out the
<a href="https://graphql.org/learn/">official docs</a>.</p>
<h2 id="graphiql-ide"><a class="header" href="#graphiql-ide">GraphiQL IDE</a></h2>
<p>Conveniently, the node service exposes a GraphQL IDE called GraphiQL. To use
GraphiQL start the node service and navigate to <code>localhost:8080/</code>.</p>
<p>Using the schema explorer on the left of the GraphiQL IDE you can dynamically
explore the state of the system and your applications.</p>
<p><img src="core_concepts/graphiql.png" alt="graphiql.png" /></p>
<h2 id="graphql-system-api"><a class="header" href="#graphql-system-api">GraphQL System API</a></h2>
<p>The node service also exposes a GraphQL API which corresponds to the set of
system operations. You can explore the full set of operations by clicking on
<code>MutationRoot</code>.</p>
<h2 id="graphql-application-api"><a class="header" href="#graphql-application-api">GraphQL Application API</a></h2>
<p>To interact with an application, we run the Linera client in service mode. It
exposes a GraphQL API for every application running on any owned chain at
<code>localhost:8080/chains/&lt;chain-id&gt;/applications/&lt;application-id&gt;</code>.</p>
<p>Navigating there with your browser will open a GraphiQL interface which enables
you to graphically explore the state of your application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applications"><a class="header" href="#applications">Applications</a></h1>
<p>The programming model of Linera is designed so that developers can take
advantage of microchains to scale their applications.</p>
<p>Linera uses the WebAssembly Virtual Machine (Wasm) to execute user applications.
Currently, the <a href="core_concepts/../sdk.html">Linera SDK</a> is focused on the
<a href="https://www.rust-lang.org/">Rust</a> programming language.</p>
<p>Linera applications are structured using the familiar notion of <strong>Rust crate</strong>:
the external interfaces of an application (including initialization parameters,
operations and messages) generally go into the library part of its crate, while
the core of each application is compiled into binary files for the Wasm
architecture.</p>
<h2 id="the-application-deployment-lifecycle"><a class="header" href="#the-application-deployment-lifecycle">The Application Deployment Lifecycle</a></h2>
<p>Linera Applications are designed to be powerful yet re-usable. For this reason
there is a distinction between the bytecode and an application instance on the
network.</p>
<p>Applications undergo a lifecycle transition aimed at making development easy and
flexible:</p>
<ol>
<li>The bytecode is built from a Rust project with the <code>linera-sdk</code> dependency.</li>
<li>The bytecode is published to the network on a microchain, and assigned an
identifier.</li>
<li>A user can create a new application instance, by providing the bytecode
identifier and initialization arguments. This process returns an application
identifier which can be used to reference and interact with the application.</li>
<li>The same bytecode identifier can be used as many times is needed by as many
users are needed to create distinct applications.</li>
</ol>
<p>Importantly, the application deployment lifecycle is abstracted from the user,
and an application can be published with a single command:</p>
<pre><code class="language-bash">linera publish-and-create &lt;contract-path&gt; &lt;service-path&gt; &lt;init-args&gt;
</code></pre>
<p>This will publish the bytecode as well as initialize the application for you.</p>
<h2 id="anatomy-of-an-application"><a class="header" href="#anatomy-of-an-application">Anatomy of an Application</a></h2>
<p>An <strong>application</strong> is broken into two major components, the <em>contract</em> and the
<em>service</em>.</p>
<p>The <strong>contract</strong> is gas-metered, and is the part of the application which
executes operations and messages, make cross-application calls and modifies the
application's state. The details are covered in more depth in the
<a href="core_concepts/../sdk.html">SDK docs</a>.</p>
<p>The <strong>service</strong> is non-metered and read-only. It is used primarily to query the
state of an application and populate the presentation layer (think front-end)
with the data required for a user interface.</p>
<p>Finally, the application's state is shared by the contract and service in the
form of a <a href="core_concepts/./../advanced_topics/views.html">View</a>, but more on that later.</p>
<h2 id="operations-and-messages"><a class="header" href="#operations-and-messages">Operations and Messages</a></h2>
<blockquote>
<p>For this section we'll be using a simplified version of the example
application called "fungible" where users can send tokens to each other.</p>
</blockquote>
<p>At the system-level, interacting with an application can be done via operations
and messages.</p>
<p><strong>Operations</strong> are defined by an application developer and each application can
have a completely different set of operations. Chain owners then actively create
operations and put them in their block proposals to interact with an
application. Other applications may also call the application by providing an
operation for it to execute, this is called a cross-application call and always
happens within the same chain. Operations for cross-application calls may return
a response value back to the caller.</p>
<p>Taking the "fungible token" application as an example, an operation for a user
to transfer funds to another user would look like this:</p>
<pre><code class="language-rust ignore"><span class="boring">extern crate serde;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span>#[derive(Debug, Deserialize, Serialize)]
pub enum Operation {
    /// A transfer from a (locally owned) account to a (possibly remote) account.
    Transfer {
        owner: AccountOwner,
        amount: Amount,
        target_account: Account,
    },
    // Meant to be extended here
}</code></pre>
<p><strong>Messages</strong> result from the execution of operations or other messages. Messages
can be sent from one chain to another, always within the same application. Block
proposers also actively include messages in their block proposal, but unlike
with operations, they are only allowed to include them in the right order
(possibly skipping some), and only if they were actually created by another
chain (or the same chain, earlier).</p>
<p>In our "fungible token" application, a message to credit an account would look
like this:</p>
<pre><code class="language-rust ignore"><span class="boring">extern crate serde;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span>#[derive(Debug, Deserialize, Serialize)]
pub enum Message {
    Credit { owner: AccountOwner, amount: Amount },
    // Meant to be extended here
}</code></pre>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<p>Operations in a block are always authenticated and messages may be
authenticated. The signer of a block becomes the authenticator of all the
operations in that block. As operations are being executed by applications,
messages can be created to be sent to other chains. When they are created, they
can be configured to be authenticated. In that case, the message receives the
same authentication as the operation that created it. If handling an incoming
message creates new messages, those may also be configured to have the same
authentication as the received message.</p>
<p>In other words, the block signer can have its authority propagated across chains
through series of messages. This allows applications to safely store user state
in chains that the user may not have the authority to produce blocks. The
application may also allow only the authorized user to change that state, and
not even the chain owner is able to override that.</p>
<p>The figure below shows four chains (A, B, C, D) and some blocks produced in
them. In this example, each chain is owned by a single owner (aka. address).
Owners are in charge of producing blocks and sign new blocks using their signing
keys. Some blocks show the operations and incoming messages they accept, where
the authentication is shown inside parenthesis. All operations produced are
authenticated by the block proposer, and if these are all single user chains,
the proposer is always the chain owner. Messages that have authentication use
the one from the operation or message that created it.</p>
<p>One example in the figure is that chain A produced a block with Operation 1,
which is authenticated by the owner of chain A (written <code>(a)</code>). That operation
sent a message to chain B, and assuming the message was sent with the
authentication forwarding enabled, it is received and executed in chain B with
the authentication of <code>(a)</code>. Another example is that chain D produced a block
with Operation 2, which is authenticated by the owner of chain D (written
<code>(d)</code>). That operation sent a message to chain C, which is executed with
authentication of <code>(d)</code> like the example before. Handling that message in chain
C produced a new message, which was sent to chain B. That message, when received
by chain B is executed with the authentication of <code>(d)</code>.</p>
<pre><code class="language-ignore">                            ┌───┐     ┌─────────────────┐     ┌───┐
       Chain A owned by (a) │   ├────►│ Operation 1 (a) ├────►│   │
                            └───┘     └────────┬────────┘     └───┘
                                               │
                                               └────────────┐
                                                            ▼
                                                ┌──────────────────────────┐
                            ┌───┐     ┌───┐     │ Message from chain A (a) │
       Chain B owned by (b) │   ├────►│   ├────►│ Message from chain C (d) |
                            └───┘     └───┘     │ Operation 3 (b)          │
                                                └──────────────────────────┘
                                                            ▲
                                                   ┌────────┘
                                                   │
                            ┌───┐     ┌──────────────────────────┐     ┌───┐
       Chain C owned by (c) │   ├────►│ Message from chain D (d) ├────►│   │
                            └───┘     └──────────────────────────┘     └───┘
                                                 ▲
                                     ┌───────────┘
                                     │
                            ┌─────────────────┐     ┌───┐     ┌───┐
       Chain D owned by (d) │ Operation 2 (d) ├────►│   ├────►│   │
                            └─────────────────┘     └───┘     └───┘
</code></pre>
<p>An example where this is used is in the Fungible application, where a <code>Claim</code>
operation allows retrieving money from a chain the user does not control (but
the user still trusts will produce a block receiving their message). Without the
<code>Claim</code> operation, users would only be able to store their tokens on their own
chains, and multi-owner and public chains would have their tokens shared between
anyone able to produce a block.</p>
<p>With the <code>Claim</code> operation, users can store their tokens on another chain where
they're able to produce blocks or where they trust the owner will produce blocks
receiving their messages. Only they are able to move their tokens, even on
chains where ownership is shared or where they are not able to produce blocks.</p>
<h2 id="registering-an-application-across-chains"><a class="header" href="#registering-an-application-across-chains">Registering an Application across Chains</a></h2>
<p>If Alice is using an application on her chain and starts interacting with Bob
via the application, e.g. sends him some tokens using the <code>fungible</code> example,
the application automatically gets registered on Bob's chain, too, as soon as he
handles the incoming cross-chain messages. After that, he can execute the
application's operations on his chain, too, and e.g. send tokens to someone.</p>
<p>But there are also cases where Bob may want to start using an application he
doesn't have yet. E.g. maybe Alice regularly makes posts using the <code>social</code>
example, and Bob wants to subscribe to her.</p>
<p>In that case, trying to execute an application-specific operation would fail,
because the application is not registered on his chain. He needs to request it
from Alice first:</p>
<pre><code class="language-bash">linera request-application &lt;application-id&gt; --target-chain-id &lt;alices-chain-id&gt;
</code></pre>
<p>Once Alice processes his message (which happens automatically if she is running
the client in service mode), he can start using the application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-linera-applications"><a class="header" href="#writing-linera-applications">Writing Linera Applications</a></h1>
<p>In this section, we'll be exploring how to create Web3 applications using the
Linera SDK.</p>
<p>We'll use a simple "counter" application as a running example.</p>
<p>We'll focus on the back end of the application, which consists of two main
parts: a <em>smart contract</em> and its GraphQL service.</p>
<p>Both the contract and the service of an application are written in Rust using
the crate <a href="https://crates.io/crates/linera-sdk"><code>linera-sdk</code></a>, and compiled to
Wasm bytecode.</p>
<p>This section should be seen as a guide versus a reference manual for the SDK.
For the reference manual, refer to the
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/">documentation of the crate</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-linera-project"><a class="header" href="#creating-a-linera-project">Creating a Linera Project</a></h1>
<p>To create your Linera project, use the <code>linera project new</code> command. The command
should be executed outside the <code>linera-protocol</code> folder. It sets up the
scaffolding and requisite files:</p>
<pre><code class="language-bash">linera project new my-counter
</code></pre>
<p><code>linera project new</code> bootstraps your project by creating the following key
files:</p>
<ul>
<li><code>Cargo.toml</code>: your project's manifest filled with the necessary dependencies
to create an app;</li>
<li><code>src/lib.rs</code>: the application's ABI definition;</li>
<li><code>src/state.rs</code>: the application's state;</li>
<li><code>src/contract.rs</code>: the application's contract, and the binary target for the
contract bytecode;</li>
<li><code>src/service.rs</code>: the application's service, and the binary target for the
service bytecode.</li>
<li><code>.cargo/config.toml</code>: modifies the default target used by <code>cargo</code> to be
<code>wasm32-unknown-unknown</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-application-state"><a class="header" href="#creating-the-application-state">Creating the Application State</a></h1>
<p>The <code>struct</code> which defines your application's state can be found in
<code>src/state.rs</code>.</p>
<p>To represent our counter, we're going to need a single <code>u64</code>. To persist the
counter we'll be using Linera's <a href="sdk/../advanced_topics/views.html">view</a> paradigm.</p>
<p>Views are a little like an
<a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">ORM</a>, however
instead of mapping data structures to a relational database like Postgres, they
are instead mapped onto key-value stores like <a href="https://rocksdb.org/">RocksDB</a>.</p>
<p>In vanilla Rust, we might represent our Counter as so:</p>
<pre><code class="language-rust ignore">// do not use this
struct Counter {
  value: u64
}</code></pre>
<p>However, to persist your data, you'll need to replace the existing <code>Application</code>
state struct in <code>src/state.rs</code> with the following view:</p>
<pre><code class="language-rust ignore">/// The application state.
#[derive(RootView, async_graphql::SimpleObject)]
#[view(context = "ViewStorageContext")]
pub struct Counter {
    pub value: RegisterView&lt;u64&gt;,
}</code></pre>
<p>and all other occurrences of <code>Application</code> in your app.</p>
<p>The <code>RegisterView&lt;T&gt;</code> supports modifying a single value of type <code>T</code>. There are
different types of views for different use-cases, but the majority of common
data structures have already been implemented:</p>
<ul>
<li>A <code>Vec</code> or <code>VecDeque</code> corresponds to a <code>LogView</code></li>
<li>A <code>BTreeMap</code> corresponds to a <code>MapView</code> if its values are primitive, or to
<code>CollectionView</code> if its values are other views;</li>
<li>A <code>Queue</code> corresponds to a <code>QueueView</code></li>
</ul>
<p>For an exhaustive list refer to the Views
<a href="sdk/../advanced_topics/views.html">documentation</a>.</p>
<p>Finally, run <code>cargo check</code> to ensure that your changes compile.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-the-abi"><a class="header" href="#defining-the-abi">Defining the ABI</a></h1>
<p>The Application Binary Interface (ABI) of a Linera application defines how to
interact with this application from other parts of the system. It includes the
data structures, data types, and functions exposed by on-chain contracts and
services.</p>
<p>ABIs are usually defined in <code>src/lib.rs</code> and compiled across all architectures
(Wasm and native).</p>
<p>For a reference guide, check out the
<a href="https://docs.rs/linera-base/latest/linera_base/abi/">documentation of the crate</a>.</p>
<h2 id="defining-a-marker-struct"><a class="header" href="#defining-a-marker-struct">Defining a marker struct</a></h2>
<p>The library part of your application (generally in <code>src/lib.rs</code>) must define a
public empty struct that implements the <code>Abi</code> trait.</p>
<pre><code class="language-rust ignore">struct CounterAbi;</code></pre>
<p>The <code>Abi</code> trait combines the <code>ContractAbi</code> and <code>ServiceAbi</code> traits to include
the types that your application exports.</p>
<pre><code class="language-rust ignore">/// A trait that includes all the types exported by a Linera application (both contract
/// and service).
pub trait Abi: ContractAbi + ServiceAbi {}</code></pre>
<p>Next, we're going to implement each of the two traits.</p>
<h2 id="contract-abi"><a class="header" href="#contract-abi">Contract ABI</a></h2>
<p>The <code>ContractAbi</code> trait defines the data types that your application uses in a
contract. Each type represents a specific part of the contract's behavior:</p>
<pre><code class="language-rust ignore">/// A trait that includes all the types exported by a Linera application contract.
pub trait ContractAbi {
    /// Immutable parameters specific to this application (e.g. the name of a token).
    type Parameters: Serialize + DeserializeOwned + Send + Sync + Clone + Debug + 'static;

    /// Initialization argument passed to a new application on the chain that created it
    /// (e.g. an initial amount of tokens minted).
    ///
    /// To share configuration data on every chain, use [`ContractAbi::Parameters`]
    /// instead.
    type InitializationArgument: Serialize + DeserializeOwned + Send + Sync + Debug + 'static;

    /// The type of operation executed by the application.
    ///
    /// Operations are transactions directly added to a block by the creator (and signer)
    /// of the block. Users typically use operations to start interacting with an
    /// application on their own chain.
    type Operation: Serialize + DeserializeOwned + Send + Sync + Debug + 'static;

    /// The response type of an application call.
    type Response: Serialize + DeserializeOwned + Send + Sync + Debug + 'static;
}</code></pre>
<p>All these types must implement the <code>Serialize</code>, <code>DeserializeOwned</code>, <code>Send</code>,
<code>Sync</code>, <code>Debug</code> traits, and have a <code>'static</code> lifetime.</p>
<p>In our example, we would like to change our <code>InitializationArgument</code>,
<code>Operation</code> to <code>u64</code>, like so:</p>
<pre><code class="language-rust"><span class="boring">extern crate linera_base;
</span><span class="boring">use linera_base::abi::ContractAbi;
</span><span class="boring">struct CounterAbi;
</span>impl ContractAbi for CounterAbi {
    type InitializationArgument = u64;
    type Parameters = ();
    type Operation = u64;
    type Response = ();
}</code></pre>
<h2 id="service-abi"><a class="header" href="#service-abi">Service ABI</a></h2>
<p>The <code>ServiceAbi</code> is in principle very similar to the <code>ContractAbi</code>, just for the
service component of your application.</p>
<p>The <code>ServiceAbi</code> trait defines the types used by the service part of your
application:</p>
<pre><code class="language-rust ignore">/// A trait that includes all the types exported by a Linera application service.
pub trait ServiceAbi {
    /// Immutable parameters specific to this application (e.g. the name of a token).
    type Parameters: Serialize + DeserializeOwned + Send + Sync + Clone + Debug + 'static;

    /// The type of a query receivable by the application's service.
    type Query: Serialize + DeserializeOwned + Send + Sync + Debug + 'static;

    /// The response type of the application's service.
    type QueryResponse: Serialize + DeserializeOwned + Send + Sync + Debug + 'static;
}</code></pre>
<p>For our Counter example, we'll be using GraphQL to query our application so our
<code>ServiceAbi</code> should reflect that:</p>
<pre><code class="language-rust"><span class="boring">extern crate linera_base;
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use linera_base::abi::ServiceAbi;
</span><span class="boring">struct CounterAbi;
</span>impl ServiceAbi for CounterAbi {
    type Query = async_graphql::Request;
    type QueryResponse = async_graphql::Response;
    type Parameters = ();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-the-contract-binary"><a class="header" href="#writing-the-contract-binary">Writing the Contract Binary</a></h1>
<p>The contract binary is the first component of a Linera application. It can
actually change the state of the application.</p>
<p>To create a contract, we need to create a new type and implement the <code>Contract</code>
trait for it, which is as follows:</p>
<pre><code class="language-rust ignore">#[async_trait]
pub trait Contract: WithContractAbi + ContractAbi + Send + Sized {
    /// The type used to report errors to the execution environment.
    type Error: Error + From&lt;serde_json::Error&gt; + From&lt;bcs::Error&gt; + 'static;

    /// The type used to store the persisted application state.
    type State: Sync;

    /// The desired storage backend used to store the application's state.
    type Storage: ContractStateStorage&lt;Self&gt; + Send + 'static;

    /// The type of message executed by the application.
    type Message: Serialize + DeserializeOwned + Send + Sync + Debug + 'static;

    /// Creates an in-memory instance of the contract handler from the application's `state`.
    async fn new(state: Self::State, runtime: ContractRuntime&lt;Self&gt;) -&gt; Result&lt;Self, Self::Error&gt;;

    /// Returns the current state of the application so that it can be persisted.
    fn state_mut(&amp;mut self) -&gt; &amp;mut Self::State;

    /// Initializes the application on the chain that created it.
    async fn initialize(
        &amp;mut self,
        argument: Self::InitializationArgument,
    ) -&gt; Result&lt;(), Self::Error&gt;;

    /// Applies an operation from the current block.
    async fn execute_operation(
        &amp;mut self,
        operation: Self::Operation,
    ) -&gt; Result&lt;Self::Response, Self::Error&gt;;

    /// Applies a message originating from a cross-chain message.
    async fn execute_message(&amp;mut self, message: Self::Message) -&gt; Result&lt;(), Self::Error&gt;;

    /// Finishes the execution of the current transaction.
    async fn finalize(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {
        Self::Storage::store(self.state_mut()).await;
        Ok(())
    }
}</code></pre>
<p>The full trait definition can be found
<a href="https://github.com/linera-io/linera-protocol/blob/main/linera-sdk/src/lib.rs">here</a>.</p>
<p>There's quite a bit going on here, so let's break it down and take one method at
a time.</p>
<p>For this application, we'll be using the <code>initialize</code> and <code>execute_operation</code>
methods.</p>
<h2 id="the-contract-lifecycle"><a class="header" href="#the-contract-lifecycle">The Contract Lifecycle</a></h2>
<p>To implement the application contract, we first create a type for the contract:</p>
<pre><code class="language-rust ignore">pub struct CounterContract {
    state: Counter,
    runtime: ContractRuntime&lt;Self&gt;,
}</code></pre>
<p>This type usually contains at least two fields: the persistent <code>state</code> defined
earlier and a handle to the runtime. The runtime provides access to information
about the current execution and also allows sending messages, among other
things. Other fields can be added, and they can be used to store volatile data
that only exists while the current transaction is being executed, and discarded
afterwards.</p>
<p>When a transaction is executed, first the application's state is loaded, then
the contract type is created by calling the <code>Contract::new</code> method. This method
receives the state and a handle to the runtime that the contract can use. For
our implementation, we will just store the received parameters:</p>
<pre><code class="language-rust ignore">    async fn new(state: Counter, runtime: ContractRuntime&lt;Self&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
        CounterContract { state, runtime }
    }</code></pre>
<p>When the transaction finishes executing successfully, there's a final step where
all loaded application contracts are allowed to <code>finalize</code>, similarly to
executing a destructor. The default implementation of <code>finalize</code> just persists
the application's state, and that's why we must provide it access to the state
through the <code>state_mut</code> method:</p>
<pre><code class="language-rust ignore">    fn state_mut(&amp;mut self) -&gt; &amp;mut Self::State {
        &amp;mut self.state
    }</code></pre>
<p>Applications may want to override the <code>finalize</code> method in more advanced
scenarios, but they must ensure they don't forget to <em>persist</em> their state if
they do so. For more information see the
<a href="sdk/../advanced_topics/contract_finalize.html">Contract finalization section</a>.</p>
<h2 id="initializing-our-application"><a class="header" href="#initializing-our-application">Initializing our Application</a></h2>
<p>The first thing that happens when an application is created from a bytecode is
that it is initialized. This is done by calling the contract's
<code>Contract::initialize</code> method.</p>
<p><code>Contract::initialize</code> is only called once when the application is created and
only on the microchain that created the application.</p>
<p>Deployment on other microchains will use the <code>Default</code> implementation of the
application state if <code>SimpleStateStorage</code> is used, or the <code>Default</code> value of all
sub-views in the state if the <code>ViewStateStorage</code> is used.</p>
<p>For our example application, we'll want to initialize the state of the
application to an arbitrary number that can be specified on application creation
using its initialization parameters:</p>
<pre><code class="language-rust ignore">    async fn initialize(&amp;mut self, value: u64) -&gt; Result&lt;(), Self::Error&gt; {
        self.state.value.set(value);
        Ok(())
    }</code></pre>
<h2 id="implementing-the-increment-operation"><a class="header" href="#implementing-the-increment-operation">Implementing the Increment Operation</a></h2>
<p>Now that we have our counter's state and a way to initialize it to any value we
would like, we need a way to increment our counter's value. Execution requests
from block proposers or other applications are broadly called 'operations'.</p>
<p>To create a new operation, we need to use the method
<code>Contract::execute_operation</code>. In the counter's case, it will be receiving a
<code>u64</code> which is used to increment the counter:</p>
<pre><code class="language-rust ignore">    async fn execute_operation(&amp;mut self, operation: u64) -&gt; Result&lt;(), Self::Error&gt; {
        let current = self.value.get();
        self.value.set(current + operation);
        Ok(())
    }</code></pre>
<h2 id="declaring-the-abi"><a class="header" href="#declaring-the-abi">Declaring the ABI</a></h2>
<p>Finally, to link our <code>Contract</code> trait implementation with the ABI of the
application, the following code is added:</p>
<pre><code class="language-rust ignore">impl WithContractAbi for CounterContract {
    type Abi = counter::CounterAbi;
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-the-service-binary"><a class="header" href="#writing-the-service-binary">Writing the Service Binary</a></h1>
<p>The service binary is the second component of a Linera application. It is
compiled into a separate Bytecode from the contract and is run independently. It
is not metered (meaning that querying an application's service does not consume
gas), and can be thought of as a read-only view into your application.</p>
<p>Application states can be arbitrarily complex, and most of the time you don't
want to expose this state in its entirety to those who would like to interact
with your app. Instead, you might prefer to define a distinct set of queries
that can be made against your application.</p>
<p>The <code>Service</code> trait is how you define the interface into your application. The
<code>Service</code> trait is defined as follows:</p>
<pre><code class="language-rust ignore">/// The service interface of a Linera application.
#[async_trait]
pub trait Service: WithServiceAbi + ServiceAbi {
    /// Type used to report errors to the execution environment.
    type Error: Error + From&lt;serde_json::Error&gt;;

    /// The type used to store the persisted application state.
    type State;

    /// The desired storage backend used to store the application's state.
    type Storage: ServiceStateStorage;

    /// Creates a in-memory instance of the service handler from the application's `state`.
    async fn new(state: Self::State, runtime: ServiceRuntime&lt;Self&gt;) -&gt; Result&lt;Self, Self::Error&gt;;

    /// Executes a read-only query on the state of this application.
    async fn handle_query(&amp;self, query: Self::Query) -&gt; Result&lt;Self::QueryResponse, Self::Error&gt;;
}</code></pre>
<p>The full service trait definition can be found
<a href="https://github.com/linera-io/linera-protocol/blob/main/linera-sdk/src/lib.rs">here</a>.</p>
<p>Let's implement <code>Service</code> for our counter application.</p>
<p>First, we create a new type for the service, similarly to the contract:</p>
<pre><code class="language-rust ignore">pub struct CounterService {
    state: Counter,
}</code></pre>
<p>Just like with the <code>CounterContract</code> type, this type usually has two types: the
application <code>state</code> and the <code>runtime</code>. We can omit the fields if we don't use
them, so in this example we're omitting the <code>runtime</code> field.</p>
<p>We need to generate the necessary boilerplate for implementing the service
<a href="https://component-model.bytecodealliance.org/design/wit.html">WIT interface</a>,
export the necessary resource types and functions so that the service can be
executed. Fortunately, there is a macro to perform this code generation, so just
add the following to <code>service.rs</code>:</p>
<pre><code class="language-rust ignore">linera_sdk::service!(CounterService);</code></pre>
<p>Next, we need to implement the <code>Service</code> trait for <code>CounterService</code> type. The
first step is to define the <code>Service</code>'s associated types:</p>
<pre><code class="language-rust ignore">#[async_trait]
impl Service for CounterService {
    type Error = Error;
    type Storage = ViewStateStorage&lt;Self&gt;;
    type State = Counter;
}</code></pre>
<p>The only type specified above that isn't yet defined is the <code>Error</code> type, so
let's create it below the trait implementation:</p>
<pre><code class="language-rust ignore">/// An error that can occur during the contract execution.
#[derive(Debug, Error)]
pub enum Error {
    /// Invalid query argument; could not deserialize GraphQL request.
    #[error("Invalid query argument; could not deserialize GraphQL request")]
    InvalidQuery(#[from] serde_json::Error),
}</code></pre>
<p>Also like in contracts, we must implement a <code>new</code> constructor when implementing
the <code>Service</code> trait. The constructor receives the state and the runtime handle:</p>
<pre><code class="language-rust ignore">    async fn new(state: Self::State, _runtime: ServiceRuntime&lt;Self&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
        Ok(CounterService { state })
    }</code></pre>
<p>The actual functionality of the service starts in the <code>handle_query</code> method. We
will accept GraphQL queries and handle them using the
<a href="https://github.com/async-graphql/async-graphql"><code>async-graphql</code> crate</a>. To
forward the queries to custom GraphQL handlers we will implement in the next
section, we use the following code:</p>
<pre><code class="language-rust ignore">    async fn handle_query(&amp;mut self, request: Request) -&gt; Result&lt;Response, Self::Error&gt; {
        let schema = Schema::build(
            // implemented in the next section
            QueryRoot { value: *self.value.get() },
            // implemented in the next section
            MutationRoot {},
            EmptySubscription,
        )
        .finish();
        Ok(schema.execute(request).await)
    }
}</code></pre>
<p>Finally, as before, the following code is needed to incorporate the ABI
definitions into your <code>Service</code> implementation:</p>
<pre><code class="language-rust ignore">impl WithServiceAbi for Counter {
    type Abi = counter::CounterAbi;
}</code></pre>
<h2 id="adding-graphql-compatibility"><a class="header" href="#adding-graphql-compatibility">Adding GraphQL compatibility</a></h2>
<p>Finally, we want our application to have GraphQL compatibility. To achieve this
we need a <code>QueryRoot</code> to respond to queries and a <code>MutationRoot</code> for creating
serialized <code>Operation</code> values that can be placed in blocks.</p>
<p>In the <code>QueryRoot</code>, we only create a single <code>value</code> query that returns the
counter's value:</p>
<pre><code class="language-rust ignore">struct QueryRoot {
    value: u64,
}

#[Object]
impl QueryRoot {
    async fn value(&amp;self) -&gt; &amp;u64 {
        &amp;self.value
    }
}</code></pre>
<p>In the <code>MutationRoot</code>, we only create one <code>increment</code> method that returns a
serialized operation to increment the counter by the provided <code>value</code>:</p>
<pre><code class="language-rust ignore">struct MutationRoot;

#[Object]
impl MutationRoot {
    async fn increment(&amp;self, value: u64) -&gt; Vec&lt;u8&gt; {
        bcs::to_bytes(&amp;value).unwrap()
    }
}</code></pre>
<p>We haven't included the imports in the above code; they are left as an exercise
to the reader (but remember to import <code>async_graphql::Object</code>). If you want the
full source code and associated tests check out the
<a href="https://github.com/linera-io/linera-protocol/blob/main/examples/counter/src/service.rs">examples section</a>
on GitHub.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-the-application"><a class="header" href="#deploying-the-application">Deploying the Application</a></h1>
<p>The first step to deploy your application is to configure a wallet. This will
determine where the application will be deployed: either to a local net or to
the devnet.</p>
<h2 id="local-net"><a class="header" href="#local-net">Local Net</a></h2>
<p>To configure the local network, follow the steps in the
<a href="sdk/../getting_started/hello_linera.html#using-the-initial-test-wallet">Getting Started section</a>.</p>
<p>Afterwards, the <code>LINERA_WALLET</code> and the <code>LINERA_STORAGE</code> environment variables
should be set and can be used in the <code>publish-and-create</code> command to deploy the
application while also specifying:</p>
<ol>
<li>The location of the contract bytecode</li>
<li>The location of the service bytecode</li>
<li>The JSON encoded initialization arguments</li>
</ol>
<pre><code class="language-bash">linera publish-and-create \
  target/wasm32-unknown-unknown/release/my-counter_{contract,service}.wasm \
  --json-argument "42"
</code></pre>
<h2 id="devnet"><a class="header" href="#devnet">Devnet</a></h2>
<p>To configure the wallet for the devnet while creating a new microchain, the
following command can be used:</p>
<pre><code class="language-bash">linera wallet init --with-new-chain --faucet https://faucet.devnet-2024-03-26.linera.net
</code></pre>
<p>The Faucet will provide the new chain with some tokens, which can then be used
to deploy the application with the <code>publish-and-create</code> command. It requires
specifying:</p>
<ol>
<li>The location of the contract bytecode</li>
<li>The location of the service bytecode</li>
<li>The JSON encoded initialization arguments</li>
</ol>
<pre><code class="language-bash">linera publish-and-create \
  target/wasm32-unknown-unknown/release/my-counter_{contract,service}.wasm \
  --json-argument "42"
</code></pre>
<h2 id="interacting-with-the-application"><a class="header" href="#interacting-with-the-application">Interacting with the Application</a></h2>
<p>To interact with the deployed application, a
<a href="sdk/../core_concepts/node_service.html">node service</a> must be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-chain-messages"><a class="header" href="#cross-chain-messages">Cross-Chain Messages</a></h1>
<p>On Linera, applications are meant to be multi-chain: They are instantiated on
every chain where they are used. An application has the same application ID and
bytecode everywhere, but a separate state on every chain. To coordinate, the
instances can send <em>cross-chain messages</em> to each other. A message sent by an
application is always handled by the <em>same</em> application on the target chain: The
handling code is guaranteed to be the same as the sending code, but the state
may be different.</p>
<p>For your application, you can specify any serializable type as the <code>Message</code>
type in your <code>ContractAbi</code> implementation. To send a message, use the
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/struct.ContractRuntime.html"><code>ContractRuntime</code></a>
made available as an argument to the contract's [<code>Contract::new</code>] constructor.
The runtime is usually stored inside the contract object, as we did when
<a href="sdk/./contract.html">writing the contract binary</a>. We can then call
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/struct.ContractRuntime.html#prepare_message"><code>ContractRuntime::prepare_message</code></a>
to start preparing a message, and then
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/struct.MessageBuilder.html#send_to"><code>send_to</code></a>
to send it to a destination chain.</p>
<pre><code class="language-rust ignore">    self.runtime
        .prepare_message(message_contents)
        .send_to(destination_chain_id);</code></pre>
<p>It is also possible to send a message to a subscription channel, so that the
message is forwarded to the subscribers of that channel. All that has to be done
is specify a
<a href="https://docs.rs/linera-base/latest/linera_base/identifiers/struct.ChannelName.html"><code>ChannelName</code></a>
as the destination parameter to <code>send_to</code>.</p>
<p>After block execution in the <em>sending</em> chain, sent messages are placed in the
<em>target</em> chains' inboxes for processing. There is no guarantee that it will be
handled: For this to happen, an owner of the target chain needs to include it in
the <code>incoming_messages</code> in one of their blocks. When that happens, the
contract's <code>execute_message</code> method gets called on their chain.</p>
<p>While preparing the message to be sent, it is possible to enable authentication
forwarding and/or tracking. Authentication forwarding means that the message is
executed with the same authenticated signer as the sender of the message, while
tracking means that the message is sent back to the sender if the receiver skips
it. The example below enables both flags:</p>
<pre><code class="language-rust ignore">    self.runtime
        .prepare_message(message_contents)
        .with_tracking()
        .with_authentication()
        .send_to(destination_chain_id);</code></pre>
<h2 id="example-fungible-token"><a class="header" href="#example-fungible-token">Example: Fungible Token</a></h2>
<p>In the
<a href="https://github.com/linera-io/linera-protocol/tree/main/examples/fungible"><code>fungible</code> example application</a>,
such a message can be the transfer of tokens from one chain to another. If the
sender includes a <code>Transfer</code> operation on their chain, it decreases their
account balance and sends a <code>Credit</code> message to the recipient's chain:</p>
<pre><code class="language-rust ignore">async fn execute_operation(
    &amp;mut self,
    operation: Self::Operation,
) -&gt; Result&lt;Self::Response, Self::Error&gt; {
    match operation {
        // ...
        Operation::Transfer {
            owner,
            amount,
            target_account,
        } =&gt; {
            self.check_account_authentication(owner)?;
            self.state.debit(owner, amount).await?;
            self.finish_transfer_to_account(amount, target_account, owner)
                .await;
            Ok(FungibleResponse::Ok)
        }
        // ...
    }
}

async fn finish_transfer_to_account(
    &amp;mut self,
    amount: Amount,
    target_account: Account,
    source: AccountOwner,
) {
    if target_account.chain_id == self.runtime.chain_id() {
        self.state.credit(target_account.owner, amount).await;
    } else {
        let message = Message::Credit {
            target: target_account.owner,
            amount,
            source,
        };
        self.runtime
            .prepare_message(message)
            .with_authentication()
            .send_to(target_account.chain_id);
    }
}</code></pre>
<p>On the recipient's chain, <code>execute_message</code> is called, which increases their
account balance.</p>
<pre><code class="language-rust ignore">async fn execute_message(&amp;mut self, message: Message) -&gt; Result&lt;(), Self::Error&gt; {
    match message {
        Message::Credit {
            amount,
            target,
            source,
        } =&gt; {
            // ...
            self.state.credit(receiver, amount).await;
        }
        // ...
    }

    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-other-applications"><a class="header" href="#calling-other-applications">Calling other Applications</a></h1>
<p>We have seen that cross-chain messages sent by an application on one chain are
always handled by the <em>same</em> application on the target chain.</p>
<p>This section is about calling other applications using <em>cross-application
calls</em>.</p>
<p>Such calls happen on the same chain and are made with the
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/struct.ContractRuntime.html#call_application"><code>ContractRuntime::call_application</code></a>
method:</p>
<pre><code class="language-rust ignore">pub fn call_application&lt;A: ContractAbi + Send&gt;(
    &amp;mut self,
    authenticated: bool,
    application: ApplicationId&lt;A&gt;,
    call: &amp;A::Operation,
) -&gt; A::Response {</code></pre>
<p>The <code>authenticated</code> argument specifies whether the callee is allowed to perform
actions that require authentication on behalf of the signer of the original
block that caused this call.</p>
<p>The <code>application</code> argument is the callee's application ID, and <code>A</code> is the
callee's ABI.</p>
<p>The <code>call</code> argument is the operation requested by the application call.</p>
<h2 id="example-crowd-funding"><a class="header" href="#example-crowd-funding">Example: Crowd-Funding</a></h2>
<p>The <code>crowd-funding</code> example application allows the application creator to launch
a campaign with a funding target. That target can be an amount specified in any
type of token based on the <code>fungible</code> application. Others can then pledge tokens
of that type to the campaign, and if the target is not reached by the deadline,
they are refunded.</p>
<p>If Alice used the <code>fungible</code> example to create a Pugecoin application (with an
impressionable pug as its mascot), then Bob can create a <code>crowd-funding</code>
application, use Pugecoin's application ID as <code>CrowdFundingAbi::Parameters</code>, and
specify in <code>CrowdFundingAbi::InitializationArgument</code> that his campaign will run
for one week and has a target of 1000 Pugecoins.</p>
<p>Now let's say Carol wants to pledge 10 Pugecoin tokens to Bob's campaign.</p>
<p>First she needs to make sure she has his crowd-funding application on her chain,
e.g. using the <code>linera request-application</code> command. This will automatically
also register Alice's application on her chain, because it is a dependency of
Bob's.</p>
<p>Now she can make her pledge by running the <code>linera service</code> and making a query
to Bob's application:</p>
<pre><code class="language-json">mutation { pledge(owner: "User:841…6c0", amount: "10") }
</code></pre>
<p>This will add a block to Carol's chain containing the pledge operation that gets
handled by <code>CrowdFunding::execute_operation</code>, resulting in one cross-application
call and two cross-chain messages:</p>
<p>First <code>CrowdFunding::execute_operation</code> calls the <code>fungible</code> application on
Carol's chain to transfer 10 tokens to Carol's account on Bob's chain:</p>
<pre><code class="language-rust ignore">// ...
let call = fungible::Operation::Transfer {
    owner,
    amount,
    target_account,
};
// ...
self.runtime
    .call_application(/* authenticated by owner */ true, fungible_id, &amp;call);</code></pre>
<p>This causes <code>Fungible::execute_operation</code> to be run, which will create a
cross-chain message sending the amount 10 to the Pugecoin application instance
on Bob's chain.</p>
<p>After the cross-application call returns, <code>CrowdFunding::execute_operation</code>
continues to create another cross-chain message
<code>crowd_funding::Message::PledgeWithAccount</code>, which informs the crowd-funding
application on Bob's chain that the 10 tokens are meant for the campaign.</p>
<p>When Bob now adds a block to his chain that handles the two incoming messages,
first <code>Fungible::execute_message</code> gets executed, and then
<code>CrowdFunding::execute_message</code>. The latter makes another cross-application call
to transfer the 10 tokens from Carol's account to the crowd-funding
application's account (both on Bob's chain). That is successful because Carol
does now have 10 tokens on this chain and she authenticated the transfer
indirectly by signing her block. The crowd-funding application now makes a note
in its application state on Bob's chain that Carol has pledged 10 Pugecoin
tokens.</p>
<p>For the complete code please take a look at the <code>crowd-funding</code> and <code>fungible</code>
applications in the <code>examples</code> folder in <code>linera-protocol</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="printing-logs-from-an-application"><a class="header" href="#printing-logs-from-an-application">Printing Logs from an Application</a></h1>
<p>Applications can use the <a href="https://crates.io/crates/log"><code>log</code> crate</a> to print
log messages with different levels of importance. Log messages are useful during
development, but they may also be useful for end users. By default the
<code>linera service</code> command will log the messages from an application if they are
of the "info" importance level or higher (briefly, <code>log::info!</code>, <code>log::warn!</code>
and <code>log::error!</code>).</p>
<p>During development it is often useful to log messages of lower importance (such
as <code>log::debug!</code> and <code>log::trace!</code>). To enable them, the <code>RUST_LOG</code> environment
variable must be set before running <code>linera service</code>. The example below enables
trace level messages from applications and enables warning level messages from
other parts of the <code>linera</code> binary:</p>
<pre><code class="language-ignore">export RUST_LOG="warn,linera_execution::wasm=trace"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h1>
<p>Linera applications can be tested using unit tests or integration tests. Both
are a bit different than usual Rust tests. Unit tests are executed inside a
WebAssembly virtual machine in an environment that simulates a single microchain
and a single application. System APIs are only available if they are mocked
using helper functions from <code>linera_sdk::test</code>.</p>
<p>Integration tests run outside a WebAssembly virtual machine, and use a simulated
validator for testing. This allows creating chains and adding blocks to them in
order to test interactions between multiple microchains and multiple
applications.</p>
<p>Applications should consider having both types of tests. Unit tests should be
used to focus on the application's internals and core functionality. Integration
tests should be used to test how the application behaves on a more complex
environment that's closer to the real network.</p>
<blockquote>
<p>In most cases, the simplest way to run both unit tests and integration tests
is to call <code>linera project test</code> from the project's directory.</p>
</blockquote>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit tests</a></h2>
<p>Unit tests are written beside the application's source code (i.e., inside the
<code>src</code> directory of the project). There are several differences to normal Rust
unit tests:</p>
<ul>
<li>
<p>the target <code>wasm32-unknown-unknown</code> must be selected;</p>
</li>
<li>
<p>the custom test runner <code>linera-wasm-test-runner</code> must be used;</p>
</li>
<li>
<p>the
<a href="https://docs.rs/webassembly-test/latest/webassembly_test/"><code>#[webassembly_test]</code></a>
attribute must be used instead of the usual <code>#[test]</code> attribute.</p>
</li>
</ul>
<p>The first two items are done automatically by <code>linera project test</code>.</p>
<p>Alternatively, one may set up the environment and run <code>cargo test</code> directly as
described <a href="sdk/testing.html#manually-configuring-the-environment">below</a>.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>A simple unit test is shown below, which tests if the application's
<code>do_something</code> method changes the application state.</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use crate::state::ApplicationState;
    use webassembly_test::webassembly_test;

    #[webassembly_test]
    fn test_do_something() {
        let mut application = ApplicationState {
            // Configure the application's initial state
            ..ApplicationState::default()
        };

        let result = application.do_something();

        assert!(result.is_ok());
        assert_eq!(application, ApplicationState {
            // Define the application's expected final state
            ..ApplicationState::default()
        });
    }
}</code></pre>
<h3 id="mocking-system-apis"><a class="header" href="#mocking-system-apis">Mocking System APIs</a></h3>
<p>Unit tests run in a constrained environment, so things like access to the
key-value store, cross-chain messages and cross-application calls can't be
executed. However, they can be simulated using mock APIs. The <code>linera-sdk::test</code>
module provides some helper functions to mock the system APIs.</p>
<p>Here's an example mocking the key-value store.</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use crate::state::ApplicationState;
    use linera_sdk::test::mock_key_value_store;
    use webassembly_test::webassembly_test;

    #[webassembly_test]
    fn test_state_is_not_persisted() {
        let mut storage = mock_key_value_store();

        // Assuming the application uses views
        let mut application = ApplicationState::load(storage.clone())
            .now_or_never()
            .expect("Mock key-value store returns immediately")
            .expect("Failed to load view from mock key-value store");

        // Assuming `do_something` changes the view, but does not persist it
        let result = application.do_something();

        assert!(result.is_ok());

        // Check that the state in memory is different from the state in storage
        assert_ne!(application, ApplicatonState::load(storage));
    }
}</code></pre>
<h3 id="running-unit-tests-with-cargo-test"><a class="header" href="#running-unit-tests-with-cargo-test">Running Unit Tests with <code>cargo test</code></a></h3>
<p>Running <code>linera project test</code> is easier, but if there's a need to run
<code>cargo test</code> explicitly to run the unit tests, Cargo must be configured to use
the custom test runner <code>linera-wasm-test-runner</code>. This binary can be built from
the repository or installed with <code>cargo install linera-sdk</code>.</p>
<pre><code class="language-bash">cd linera-protocol
cargo build -p linera-sdk --bin linera-wasm-test-runner --release
</code></pre>
<p>The steps above build the <code>linera-wasm-test-runner</code> and places the resulting
binary at <code>linera-protocol/target/release/linera-wasm-test-runner</code>.</p>
<p>With the binary available, the last step is to configure Cargo. There are a few
ways to do this. A quick way is to set the
<code>CARGO_TARGET_WASM32_UNKNOWN_UNKNOWN_RUNNER</code> environment variable to the path of
the binary.</p>
<p>A more persistent way is to change one of
<a href="https://doc.rust-lang.org/cargo/reference/config.html#hierarchical-structure">Cargo's configuration files</a>.
As an example, the following file can be placed inside the project's directory
at <code>PROJECT_DIR/.cargo/config.toml</code>:</p>
<pre><code class="language-ignore">[target.wasm32-unknown-unknown]
runner = "PATH_TO/linera-wasm-test-runner"
</code></pre>
<p>After configuring the test runner, unit tests can be executed with</p>
<pre><code class="language-bash">cargo test --target wasm32-unknown-unknown
</code></pre>
<p>Optionally, <code>wasm32-unknown-unknown</code> can be made the default build target with
the following lines in <code>PROJECT_DIR/.cargo/config.toml</code>:</p>
<pre><code class="language-ignore">[build]
target = "wasm32-unknown-unknown"
</code></pre>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h2>
<p>Integration tests are usually written separately from the application's source
code (i.e., inside a <code>tests</code> directory that's beside the <code>src</code> directory).</p>
<p>Integration tests are normal Rust integration tests, and they are compiled to
the <strong>host</strong> target instead of the <code>wasm32-unknown-unknown</code> target used for unit
tests. This is because unit tests run inside a WebAssembly virtual machine and
integration tests run outside a virtual machine, starting isolated virtual
machines to run each operation of each block added to each chain.</p>
<blockquote>
<p>Integration tests can be run with <code>linera project test</code> or simply
<code>cargo test</code>.</p>
</blockquote>
<p>If you wish to use <code>cargo test</code> and have overridden your default target to be in
<code>wasm32-unknown-unknown</code> in <code>.cargo/config.toml</code>, you will have to pass a native
target to <code>cargo</code>, for instance <code>cargo test --target aarch64-apple-darwin</code>.</p>
<p>Integration tests use the helper types from <code>linera_sdk::test</code> to set up a
simulated Linera network, and publish blocks to microchains in order to execute
the application.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>A simple test that sends a message between application instances on different
chains is shown below.</p>
<pre><code class="language-rust ignore">#[tokio::test]
async fn test_cross_chain_message() {
    let (validator, application_id) = TestValidator::with_current_application(vec![], vec![]).await;

    let mut sender_chain = validator.get_chain(application_id.creation.chain_id).await;
    let mut receiver_chain = validator.new_chain().await;

    sender_chain
        .add_block(|block| {
            block.with_operation(
                application_id,
                Operation::SendMessageTo(receiver_chain.id()),
            )
        })
        .await;

    receiver_chain.handle_received_messages().await;

    assert_eq!(
        receiver_chain
            .query::&lt;ChainId&gt;(application_id, Query::LastSender)
            .await,
        sender_chain.id(),
    );
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h1>
<p>In this section, we present additional topics related to the Linera protocol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="views"><a class="header" href="#views">Views</a></h1>
<blockquote>
<p>Views are a specific functionality of the Linera system that allow to have
data in memory and then seamlessly flush it to an underlying persistent
datastore.</p>
</blockquote>
<p>The <a href="https://docs.rs/linera-views/latest/linera_views/">full documentation</a> is
available on the crate documentation with all functions having examples.</p>
<p>Concretely, what is provided is the following:</p>
<ul>
<li>
<p>A trait <code>View</code> that provides <code>load</code>, <code>rollback</code>, <code>clear</code>, <code>flush</code>, <code>delete</code>.
The idea is that we can do operation on the data and then flush it to the
database storing them.</p>
</li>
<li>
<p>Several other traits <code>HashableView</code>, <code>RootView</code>, <code>CryptoHashView</code>,
<code>CryptoHashRootView</code> that are important for computing hash.</p>
</li>
<li>
<p>A number of standard containers: <code>MapView</code>, <code>SetView</code>, <code>LogView</code>, <code>QueueView</code>,
<code>RegisterView</code> that implement the <code>View</code> and <code>HashableView</code> traits.</p>
</li>
<li>
<p>Two containers <code>CollectionView</code> and <code>ReentrantCollectionView</code> that are similar
to <code>MapView</code> but whose values are views themselves.</p>
</li>
<li>
<p>Derive macros that allow to implement the above mentioned traits on struct
data types whose entries are views.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="persistent-storage"><a class="header" href="#persistent-storage">Persistent storage</a></h1>
<p>Validators run the servers and the data is stored in persistent storage. As a
consequence we need a tool for working with persistent storage and so we have
added <code>linera-db</code> for that purpose.</p>
<h2 id="available-persistent-storage"><a class="header" href="#available-persistent-storage">Available persistent storage</a></h2>
<p>The persistent storage that are available right now are <code>RocksDB</code>, <code>DynamoDB</code>
and <code>ScyllaDB</code>. Each has its own strengths and weaknesses.</p>
<ul>
<li>
<p><a href="https://rocksdb.org/"><code>RocksDB</code></a>: Data is stored on disk and cannot be shared
between shards but is very fast.</p>
</li>
<li>
<p><a href="https://aws.amazon.com/dynamodb/"><code>DynamoDB</code></a>: Data is stored on a remote
storage, that has to be on AWS. Data can be shared between shards.</p>
</li>
<li>
<p><a href="https://www.scylladb.com/"><code>ScyllaDB</code></a>: Data is stored on a remote storage.
Data can be shared between shards.</p>
</li>
</ul>
<p>There is no fundamental obstacle to the addition of other persistent storage
solutions.</p>
<p>In addition, the <code>DynamoDB</code> and <code>ScyllaDB</code> have the notion of a table which
means that a given remote location can be used for several completely
independent purposes.</p>
<h2 id="the-linera-db-tool"><a class="header" href="#the-linera-db-tool">The <code>linera-db</code> tool</a></h2>
<p>When operating on a persistent storage some global operations can be required.
The command line tool <code>linera-db</code> helps in making them work.</p>
<p>The functionalities are the following:</p>
<ul>
<li>
<p><code>list_tables</code>(<code>DynamoDB</code> and <code>ScyllaDB</code>): It lists all the tables that have
been created on the persistent storage</p>
</li>
<li>
<p><code>initialize</code>(<code>RocksDB</code>, <code>DynamoDB</code> and <code>ScyllaDB</code>): It initializes a
persistent storage.</p>
</li>
<li>
<p><code>check_existence</code>(<code>RocksDB</code>, <code>DynamoDB</code> and <code>ScyllaDB</code>): It tests the
existence of a persistent storage. If the error code is 0 then the table
exists, if the error code is 1 then the table is absent.</p>
</li>
<li>
<p><code>check_absence</code>(<code>RocksDB</code>, <code>DynamoDB</code> and <code>ScyllaDB</code>): It tests the absence of
a persistent storage. If the error code is 0 then the table is absent, if the
error code is 1 then the table does not exist.</p>
</li>
<li>
<p><code>delete_all</code>(<code>RocksDB</code>, <code>DynamoDB</code> and <code>ScyllaDB</code>): It deletes all the table
of a persistent storage.</p>
</li>
<li>
<p><code>delete_single</code>(<code>DynamoDB</code> and <code>ScyllaDB</code>): It deletes a single table of a
persistent storage.</p>
</li>
</ul>
<p>If some error occurs during the operation, then the error code 2 is returned and
0 if everything went fine with the exception of <code>check_existence</code> and
<code>check_absence</code> for which the value 1 can occur if the connection with the
database was established correctly but the result is not what we expected.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-finalization"><a class="header" href="#contract-finalization">Contract Finalization</a></h1>
<p>When a transaction finishes executing successfully, there's a final step where
all loaded application contracts are allowed to <code>finalize</code>, similarly to
executing a destructor. The default implementation of <code>finalize</code> just persists
the application's state:</p>
<pre><code class="language-rust ignore">    /// Finishes the execution of the current transaction.
    async fn finalize(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {
        Self::Storage::store(self.state_mut()).await;
        Ok(())
    }</code></pre>
<p>Applications may want to override the <code>finalize</code> method, which allows performing
some clean-up operations after execution finished. While finalizing, contracts
may send messages, read and write to the state, but are not allowed to call
other applications, because they are all also finalizing.</p>
<blockquote>
<p>If <code>finalize</code> is overriden, the default implementation is <strong>not</strong> executed, so
the developer must ensure that the application's state is persisted correctly.</p>
</blockquote>
<p>While finalizing, contracts can force the transaction to fail by panicking or
returning an error. The block is then rejected, even if the entire transaction's
operation had succeeded before <code>finalize</code> was called. This allows a contract to
reject transactions if other applications don't follow any required constraints
it establishes after it responds to a cross-application call.</p>
<p>As an example, a contract that executes a cross-application call with
<code>Operation::StartSession</code> may require the same caller to perform another
cross-application call with <code>Operation::EndSession</code> before the transaction ends.</p>
<pre><code class="language-rust ignore">pub struct MyContract {
    state: MyState;
    runtime: ContractRuntime&lt;Self&gt;;
    active_sessions: HashSet&lt;ApplicationId&gt;;
}

#[async_trait]
impl Contract for MyContract {
    type Error = MyError;
    type State = MyState;
    type Storage = ViewStateStorage&lt;Self&gt;;
    type Message = ();

    async fn new(state: Self::State, runtime: ContractRuntime&lt;Self&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
        MyContract {
            state,
            runtime,
            active_sessions: HashSet::new(),
        }
    }

    fn state_mut(&amp;mut self) -&gt; &amp;mut Self::State {
        &amp;mut self.state
    }

    async fn initialize(
        &amp;mut self,
        argument: Self::InitializationArgument,
    ) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn execute_operation(
        &amp;mut self,
        operation: Self::Operation,
    ) -&gt; Result&lt;Self::Response, Self::Error&gt; {
        let caller = self.runtime
            .authenticated_caller_id()
            .expect("Missing caller ID");

        match operation {
            Operation::StartSession =&gt; {
                assert!(
                    self.active_sessions.insert(caller_id),
                    "Can't start more than one session for the same caller"
                );
            }
            Operation::EndSession =&gt; {
                assert!(
                    self.active_sessions.remove(&amp;caller_id),
                    "Session was not started"
                );
            }
        }
    }

    async fn execute_message(&amp;mut self, message: Self::Message) -&gt; Result&lt;(), Self::Error&gt; {
        unreachable!("This example doesn't support messages");
    }

    async fn finalize(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {
        assert!(
            self.active_sessions.is_empty(),
            "Some sessions have not ended"
        );

        Self::Storage::store(self.state_mut()).await;

        Ok(())
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validators"><a class="header" href="#validators">Validators</a></h1>
<p>Validators run the servers that allow users to download and create blocks. They
validate, execute and cryptographically certify the blocks of all the chains.</p>
<blockquote>
<p>In Linera, every chain is backed by the same set of validators and has the
same level of security.</p>
</blockquote>
<p>The main function of validators is to guarantee the integrity of the
infrastructure in the sense that:</p>
<ul>
<li>
<p>Each block is valid, i.e. it has the correct format, its operations are
allowed, the received messages are in the correct order, and e.g. the balance
was correctly computed.</p>
</li>
<li>
<p>Every message received by one chain was actually sent by another chain.</p>
</li>
<li>
<p>If one block on a particular height is certified, no other block on the same
height is.</p>
</li>
</ul>
<p>These properties are guaranteed to hold as long as two third of the validators
(weighted by their stake) follow the protocol. In the future, deviating from the
protocol may cause a validator to be considered malicious and to lose their
<em>stake</em>.</p>
<p>Validators also play a role in the liveness of the system by making sure that
the history of the chains stays available. However, since validators do not
propose blocks on most chains (see <a href="advanced_topics/block_creation.html">next section</a>), they do
<em>not</em> guarantee that any particular operation or message will eventually be
executed on a chain. Instead, chain owners decide whether and when to propose
new blocks, and which operations and messages to include. The current
implementation of the Linera client automatically includes all incoming messages
in new blocks. The operations are the actions the chain owner explicitly adds,
e.g. transfer.</p>
<h2 id="architecture-of-a-validator"><a class="header" href="#architecture-of-a-validator">Architecture of a validator</a></h2>
<p>Since every chain uses the same validators, adding more chains does not require
adding validators. Instead, it requires each individual validator to scale out
by adding more computation units, also known as "workers" or "physical shards".</p>
<p>In the end, a Linera validator resembles a Web2 service made of</p>
<ul>
<li>
<p>a load balancer (aka. ingress/egress), currently implemented by the binary
<code>linera-proxy</code>,</p>
</li>
<li>
<p>a number of workers, currently implemented by the binary <code>linera-server</code>,</p>
</li>
<li>
<p>a shared database, currently implemented by the abstract interface
<code>linera-storage</code>.</p>
</li>
</ul>
<pre><code class="language-ignore">Example of Linera network

                    │                                             │
                    │                                             │
┌───────────────────┼───────────────────┐     ┌───────────────────┼───────────────────┐
│ validator 1       │                   │     │ validator N       │                   │
│             ┌─────┴─────┐             │     │             ┌─────┴─────┐             │
│             │   load    │             │     │             │   load    │             │
│       ┌─────┤  balancer ├────┐        │     │       ┌─────┤  balancer ├──────┐      │
│       │     └───────────┘    │        │     │       │     └─────┬─────┘      │      │
│       │                      │        │     │       │           │            │      │
│       │                      │        │     │       │           │            │      │
│  ┌────┴─────┐           ┌────┴─────┐  │     │  ┌────┴───┐  ┌────┴────┐  ┌────┴───┐  │
│  │  worker  ├───────────┤  worker  │  │ ... │  │ worker ├──┤  worker ├──┤ worker │  │
│  │    1     │           │    2     │  │     │  │    1   │  │    2    │  │    3   │  │
│  └────┬─────┘           └────┬─────┘  │     │  └────┬───┘  └────┬────┘  └────┬───┘  │
│       │                      │        │     │       │           │            │      │
│       │                      │        │     │       │           │            │      │
│       │     ┌───────────┐    │        │     │       │     ┌─────┴─────┐      │      │
│       └─────┤  shared   ├────┘        │     │       └─────┤  shared   ├──────┘      │
│             │ database  │             │     │             │ database  │             │
│             └───────────┘             │     │             └───────────┘             │
└───────────────────────────────────────┘     └───────────────────────────────────────┘

</code></pre>
<p>Inside a validator, components communicate using the internal network of the
validator. Notably, workers use direct Remote Procedure Calls (RPCs) with each
other to deliver cross-chain messages.</p>
<p>Note that the number of workers may vary for each validator. Both the load
balancer and the shared database are represented as a single entity but are
meant to scale out in production.</p>
<blockquote>
<p>For local testing during development, we currently use a single worker and
RocksDB as a database.</p>
</blockquote>
<!--
## Configuring Networks, Workers, and Proxies

In [a previous section](../getting_started/hello_linera.md), we used the
`linera net up` command to start a local network. This should be sufficient for
most use cases when you're running a local network.

```bash
linera net up
```

However, it is possible to customize and configure the parameters of the
network.

To do this, you need the `linera-protocol` repository and the
`./scripts/run_local.sh` script.

`run_local.sh` uses the `validator_n.toml` file from the `configuration/`
directory to configure validator number `n`.

```bash
linera-server generate --validators configuration/validator_{1,2,3,4}.toml --committee committee.json
```

generates keys and writes them, together with the options from the TOML files,
to `server_1.json`, ..., `server_4.json`. It also stores the set of the new
validators' public keys in `committee.json`.

```bash
linera --wallet wallet.json --storage rocksdb:linera.db create-genesis-config 10 --genesis genesis.json --initial-funding 10 --committee committee.json
```

creates a configuration for the initial state of the network, `genesis.json`,
with 10 chains, each with a balance of 10. It also creates a `wallet.json` for a
client who owns all those chains and initializes the corresponding local node
`linera.db`.

To start the newly configured network, each validator `n` must start their
proxy:

```bash
linera-proxy server_n.json &
```

And all shards; for shard `i`:

```bash
linera-server run --storage rocksdb:server_n_i.db --server server_n.json --shard i --genesis genesis.json &
```

This will create a separate database file `server_n_i.db` for each shard. In a
production network, these would be running on different machines.

## Changing the Set of Validators

If a new validator wants to start participating, or an old one wants to leave,
all chains must be updated.

The system has one designated _admin chain_, where the validators can join or
leave, and where new _epochs_ are defined. During every epoch, the set of
validators is fixed. If you own the admin chain, you can use the `set-validator`
and `remove-validator` commands to start a new epoch with a modified set of
validators:

```bash
linera --wallet wallet.json set-validator --name 5b611b86cc1f54f73a4abfb4a2167c7327cc85a74cb2a5502431f67b554850b4 --address 127.0.0.1:9100 --votes 3
linera --wallet wallet.json remove-validator --name f65a585f05852f0610e2460a99c23faa3969f3cfce8a519f843a793dbfb4cb84
```

Chain owners must then create a block that receives the `SetCommittees` message
from the admin chain, and have it certified by the old validators. Only the
_next_ block in their chain will be certified by the new validator set!

The _admin chain_ is currently managed by a single user. In the future, it will
be a _public chain_ (i.e. managed by validators). We anticipate that Linera
epochs will change once per day (or less) and that several subsequent epochs
will overlap so that chain owners have enough time to migrate their chains.
(Chain migration may also be delegated to third parties. See
[next section](block_creation.html).)

-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-new-blocks"><a class="header" href="#creating-new-blocks">Creating New Blocks</a></h1>
<blockquote>
<p>In Linera, the responsibility of proposing blocks is separate from the task of
validating blocks.</p>
</blockquote>
<p>While all chains are validated in the same way, the Linera protocol defines
several types of chains, depending on how new blocks are produced.</p>
<ul>
<li>
<p>The simplest and lowest-latency type of chain is called <em>single-owner</em> chain.</p>
</li>
<li>
<p>Other types of Linera chains not currently supported in the SDK include
<em>permissioned chains</em> and <em>public chains</em> (see the
<a href="https://linera.io/whitepaper">whitepaper</a> for more context).</p>
</li>
</ul>
<blockquote>
<p>For most types of chains (all but <em>public chains</em>), Linera validators do not
need to exchange messages with each other.</p>
</blockquote>
<p>Instead, the wallets (aka. <code>linera</code> clients) of chain owners make the system
progress by proposing blocks and actively providing any additional required data
to the validators. For instance, client commands such as <code>transfer</code>,
<code>publish-bytecode</code>, or <code>open-chain</code> perform multiple steps to append a block
containing the token transfer, application publishing, or chain creation
operation:</p>
<ul>
<li>
<p>The Linera client creates a new block containing the desired operation and new
incoming messages, if there are any. It also contains the most recent block's
hash to designate its parent. The client sends the new block to all
validators.</p>
</li>
<li>
<p>The validators validate the block, i.e. check that the block satisfies the
conditions listed above, and send a cryptographic signature to the client,
indicating that they vote to append the new block. But only if they have not
voted for a different block on the same height earlier!</p>
</li>
<li>
<p>The client ideally receives a vote from every validator, but only a quorum of
votes (say, two thirds) are required: These constitute a "certificate",
proving that the block was confirmed. The client sends the certificate to
every validator.</p>
</li>
<li>
<p>The validators "execute" the block: They update their own view of the most
recent state of the chain by applying all messages and operations, and if it
generated any cross-chain messages, they send these to the appropriate
workers.</p>
</li>
</ul>
<p>To guarantee that each incoming message in a block was actually sent by another
chain, a validator will, in the second step, only <em>vote</em> for a block if it has
already executed the block that sent it. However, when receiving a valid
certificate for a block that receives a message it has not seen yet, it will
accept and <em>execute</em> the block anyway. The certificate is proof that most other
validators have seen the message, so it must be correct.</p>
<p>In the case of single-owner chains, clients must be carefully implemented so
that they never propose multiple blocks at the same height. Otherwise, the chain
may be stuck: once each of the two conflicting blocks has been signed by enough
validators, it becomes impossible to collect a quorum of votes for either block.</p>
<p>In the future, we anticipate that most users will use <em>permissioned chains</em> even
if they are the only owners of their chains. Permissioned chains have two
confirmation steps instead of one, but it is not possible to accidentally make a
chain unextendable. They also allow users to delegate certain admistrative tasks
to third-parties, notably to help with epoch changes (i.e. when the validators
change if reconfigured).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applications-that-handle-assets"><a class="header" href="#applications-that-handle-assets">Applications that Handle Assets</a></h1>
<p>In general, if you send tokens to a chain owned by someone else, you rely on
them for asset availability: if they don't handle your messages, you don't have
access to your tokens.</p>
<p>Fortunately, Linera provides a solution based on temporary chains: if the number
of parties who want to participate is limited and known in advance, we can:</p>
<ul>
<li>make them all chain owners using the <code>linera change-ownership</code> command,</li>
<li>allow only one application's operations on the chain,</li>
<li>and allow only that operation to close the chain, using
<code>linera change-application-permissions</code>.</li>
</ul>
<p>Such an application should have a designated operation or message that causes it
to close the chain: when that operation is executed, it should send back all
remaining assets, and call the runtime's <code>close_chain</code> method.</p>
<p>Once the chain is closed, owners can still create blocks rejecting messages.
That way, even assets that are in flight can be returned.</p>
<p>The
<a href="https://github.com/linera-io/linera-protocol/tree/main/examples/matching-engine"><code>matching-engine</code> example application</a>
does this:</p>
<pre><code class="language-rust ignore">    async fn execute_operation(&amp;mut self, operation: Operation) -&gt; Result&lt;(), Self::Error&gt; {
        match operation {
            // ...
            Operation::CloseChain =&gt; {
                for order_id in self.state.orders.indices().await? {
                    match self.modify_order(order_id, ModifyAmount::All).await {
                        Ok(transfer) =&gt; self.send_to(transfer),
                        // Orders with amount zero may have been cleared in an earlier iteration.
                        Err(MatchingEngineError::OrderNotPresent) =&gt; continue,
                        Err(error) =&gt; return Err(error),
                    }
                }
                self.runtime
                    .close_chain()
                    .map_err(|_| MatchingEngineError::CloseChainError)?;
            }
        }
    }</code></pre>
<p>This enables doing atomic swaps using the Matching Engine: if you make a bid,
you are guaranteed that at any point in time you can get back either the tokens
you are offering or the tokens you bought.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<ul>
<li>
<p><strong>Address</strong>: A unique public alphanumeric identifier used to designate the
identity of an entity on the Linera network.</p>
</li>
<li>
<p><strong>Admin Chain</strong>: The Linera Network has one designated <em>admin chain</em> where
validators can join or leave and where new epochs are defined.</p>
</li>
<li>
<p><strong>Application</strong>: Similar to a smart-contract on Ethereum, an application is
code deployed on the Linera network which is executed by all validators. An
application has a metered <em>contract</em> which executes 'business logic' and
modifies state and an unmetered 'service' which is a read-only view into an
application's state.</p>
</li>
<li>
<p><strong>Byzantine Fault-Tolerant (BFT)</strong>: A system which can operate correctly and
achieve consensus even if components of the system fail or act maliciously.</p>
</li>
<li>
<p><strong>Block Height</strong>: The number of blocks preceding a given block on a specific
microchain.</p>
</li>
<li>
<p><strong>Block Proposal</strong>: A candidate block proposed by a chain owner which may be
selected at the next block height.</p>
</li>
<li>
<p><strong>Bytecode</strong>: A collection of bytes corresponding to a program that can be run
by the Wasm virtual machine.</p>
</li>
<li>
<p><strong>Client</strong>: The <code>linera</code> program, which is a local node and wallet operated by
users to make requests to the network. In Linera, clients drive the network by
proposing new blocks and validators are mostly reactive.</p>
</li>
<li>
<p><strong>Certificate</strong>: A value with signatures from a quorum of validators. Values
can be confirmed blocks, meaning that the block has been added to the chain
and is final. There are other values that are used for reaching consensus,
before certifying a confirmed block.</p>
</li>
<li>
<p><strong>Committee</strong>: The set of all validators for a particular <em>epoch</em>, together
with their voting weights.</p>
</li>
<li>
<p><strong>Chain Owner</strong>: The owner of a <em>user chain</em> or <em>permissioned chain</em>. This is
represented as the alphanumeric identifier derived from the hash of the
owner's public key.</p>
</li>
<li>
<p><strong>Channel</strong>: A broadcast mechanism enabling publish-subscribe behavior across
chains.</p>
</li>
<li>
<p><strong>Contract</strong>: The metered part of an application which executes business logic
and can modify the application's state.</p>
</li>
<li>
<p><strong>Cross-Application Call</strong>: A call from one application to another on the
<em>same chain</em>.</p>
</li>
<li>
<p><strong>Cross-Chain Message</strong>: A message containing a data payload which is sent
from one chain to another. Cross-Chain messages are the asynchronous
communication primitive which enable communication on the same application
running on different chains.</p>
</li>
<li>
<p><strong>Epoch</strong>: A period of time when a particular set of validators with
particular voting weights can certify new blocks. Since each chain has to
transition explicitly from one epoch to the next, epochs can overlap.</p>
</li>
<li>
<p><strong>Genesis Configuration</strong>: The configuration determining the state of a newly
created network; the voting weights of the initial set of validators, the
initial fee structure, and initial chains that the network starts with.</p>
</li>
<li>
<p><strong>Inbox</strong>: A commutative data structure storing incoming messages for a given
chain.</p>
</li>
<li>
<p><strong>Message</strong>: See 'Cross-Chain Message'.</p>
</li>
<li>
<p><strong>Microchain</strong>: A lightweight chain of blocks holding a subset of the
network's state running on every validator. This is used interchangeably with
'chain'. <em>All</em> Linera chains are microchains.</p>
</li>
<li>
<p><strong>Network</strong>: The totality of all protocol participants. A network is the
combination of committee, clients and auditors.</p>
</li>
<li>
<p><strong>Operation</strong>: Operations are either transactions directly added to a block by
the creator (and signer) of the block, or calls to an application from
another. Users typically use operations to start interacting with an
application on their own chain.</p>
</li>
<li>
<p><strong>Permissioned Chain</strong>: A microchain which is owned by more than one user.
Users take turns proposing blocks and the likelihood of selection is
proportional to their <em>weight</em>.</p>
</li>
<li>
<p><strong>Project</strong>: The collection of files and dependencies which are built into the
bytecode which is instantiated as an application on the Linera Network.</p>
</li>
<li>
<p><strong>Public Chain</strong>: A microchain with full BFT consensus with a strict set of
permissions relied on for the operation of the network,</p>
</li>
<li>
<p><strong>Quorum</strong>: A set of validators representing &gt; ⅔ of the total stake. A quorum
is required to create a certificate.</p>
</li>
<li>
<p><strong>Single-Owner Chain</strong>: See 'User Chain'.</p>
</li>
<li>
<p><strong>Service</strong>: An unmetered read-only view into an application's state.</p>
</li>
<li>
<p><strong>Shard</strong>: A logical subset of all microchains on a given validator. This
corresponds directly to a physical <em>worker</em>.</p>
</li>
<li>
<p><strong>Stake</strong>: An amount of tokens pledged by a validator or auditor, as a
collateral to guarantee their honest and correct participation in the network.</p>
</li>
<li>
<p><strong>User Chain</strong>: Used interchangeably with <em>Single-Owner Chain</em>. User chains
are chains which are owned by a single user on the network. Only the chain
owner can propose blocks, and therefore only the chain owner can forcibly
advance the state of a user chain.</p>
</li>
<li>
<p><strong>Validator</strong>: Validators run the servers that allow users to download and
create blocks. They validate, execute and cryptographically certify the blocks
of all the chains.</p>
</li>
<li>
<p><strong>View</strong>: Views are like an Object-Relational Mapping (ORM) for mapping
complex types onto key-value stores. Views group complex state changes into a
set of elementary operations and commit them atomically. They are full or
partial in-memory representations of complex types saved on disk in a
key-value store</p>
</li>
<li>
<p><strong>Wallet</strong>: A file containing a user's public and private keys along with
configuration and information regarding the chains they own.</p>
</li>
<li>
<p><strong>WebAssembly (Wasm)</strong>: A binary compilation target and instruction format
that runs on a stack-based VM. Linera applications are compiled to Wasm and
run on Wasm VMs inside validators and clients.</p>
</li>
<li>
<p><strong>Web3</strong>: A natural evolution of the internet focusing on decentralization by
leveraging blockchains and smart contracts.</p>
</li>
<li>
<p><strong>Worker</strong>: A process which runs a subset of all microchains on a given
validator. This corresponds directly to a logical <em>shard</em>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary-1"><a class="header" href="#glossary-1">Glossary</a></h1>
<ul>
<li>
<p><strong>Address</strong>: A unique public alphanumeric identifier used to designate the
identity of an entity on the Linera network.</p>
</li>
<li>
<p><strong>Admin Chain</strong>: The Linera Network has one designated <em>admin chain</em> where
validators can join or leave and where new epochs are defined.</p>
</li>
<li>
<p><strong>Application</strong>: Similar to a smart-contract on Ethereum, an application is
code deployed on the Linera network which is executed by all validators. An
application has a metered <em>contract</em> which executes 'business logic' and
modifies state and an unmetered 'service' which is a read-only view into an
application's state.</p>
</li>
<li>
<p><strong>Byzantine Fault-Tolerant (BFT)</strong>: A system which can operate correctly and
achieve consensus even if components of the system fail or act maliciously.</p>
</li>
<li>
<p><strong>Block Height</strong>: The number of blocks preceding a given block on a specific
microchain.</p>
</li>
<li>
<p><strong>Block Proposal</strong>: A candidate block proposed by a chain owner which may be
selected at the next block height.</p>
</li>
<li>
<p><strong>Bytecode</strong>: A collection of bytes corresponding to a program that can be run
by the Wasm virtual machine.</p>
</li>
<li>
<p><strong>Client</strong>: The <code>linera</code> program, which is a local node and wallet operated by
users to make requests to the network. In Linera, clients drive the network by
proposing new blocks and validators are mostly reactive.</p>
</li>
<li>
<p><strong>Certificate</strong>: A value with signatures from a quorum of validators. Values
can be confirmed blocks, meaning that the block has been added to the chain
and is final. There are other values that are used for reaching consensus,
before certifying a confirmed block.</p>
</li>
<li>
<p><strong>Committee</strong>: The set of all validators for a particular <em>epoch</em>, together
with their voting weights.</p>
</li>
<li>
<p><strong>Chain Owner</strong>: The owner of a <em>user chain</em> or <em>permissioned chain</em>. This is
represented as the alphanumeric identifier derived from the hash of the
owner's public key.</p>
</li>
<li>
<p><strong>Channel</strong>: A broadcast mechanism enabling publish-subscribe behavior across
chains.</p>
</li>
<li>
<p><strong>Contract</strong>: The metered part of an application which executes business logic
and can modify the application's state.</p>
</li>
<li>
<p><strong>Cross-Application Call</strong>: A call from one application to another on the
<em>same chain</em>.</p>
</li>
<li>
<p><strong>Cross-Chain Message</strong>: A message containing a data payload which is sent
from one chain to another. Cross-Chain messages are the asynchronous
communication primitive which enable communication on the same application
running on different chains.</p>
</li>
<li>
<p><strong>Epoch</strong>: A period of time when a particular set of validators with
particular voting weights can certify new blocks. Since each chain has to
transition explicitly from one epoch to the next, epochs can overlap.</p>
</li>
<li>
<p><strong>Genesis Configuration</strong>: The configuration determining the state of a newly
created network; the voting weights of the initial set of validators, the
initial fee structure, and initial chains that the network starts with.</p>
</li>
<li>
<p><strong>Inbox</strong>: A commutative data structure storing incoming messages for a given
chain.</p>
</li>
<li>
<p><strong>Message</strong>: See 'Cross-Chain Message'.</p>
</li>
<li>
<p><strong>Microchain</strong>: A lightweight chain of blocks holding a subset of the
network's state running on every validator. This is used interchangeably with
'chain'. <em>All</em> Linera chains are microchains.</p>
</li>
<li>
<p><strong>Network</strong>: The totality of all protocol participants. A network is the
combination of committee, clients and auditors.</p>
</li>
<li>
<p><strong>Operation</strong>: Operations are either transactions directly added to a block by
the creator (and signer) of the block, or calls to an application from
another. Users typically use operations to start interacting with an
application on their own chain.</p>
</li>
<li>
<p><strong>Permissioned Chain</strong>: A microchain which is owned by more than one user.
Users take turns proposing blocks and the likelihood of selection is
proportional to their <em>weight</em>.</p>
</li>
<li>
<p><strong>Project</strong>: The collection of files and dependencies which are built into the
bytecode which is instantiated as an application on the Linera Network.</p>
</li>
<li>
<p><strong>Public Chain</strong>: A microchain with full BFT consensus with a strict set of
permissions relied on for the operation of the network,</p>
</li>
<li>
<p><strong>Quorum</strong>: A set of validators representing &gt; ⅔ of the total stake. A quorum
is required to create a certificate.</p>
</li>
<li>
<p><strong>Single-Owner Chain</strong>: See 'User Chain'.</p>
</li>
<li>
<p><strong>Service</strong>: An unmetered read-only view into an application's state.</p>
</li>
<li>
<p><strong>Shard</strong>: A logical subset of all microchains on a given validator. This
corresponds directly to a physical <em>worker</em>.</p>
</li>
<li>
<p><strong>Stake</strong>: An amount of tokens pledged by a validator or auditor, as a
collateral to guarantee their honest and correct participation in the network.</p>
</li>
<li>
<p><strong>User Chain</strong>: Used interchangeably with <em>Single-Owner Chain</em>. User chains
are chains which are owned by a single user on the network. Only the chain
owner can propose blocks, and therefore only the chain owner can forcibly
advance the state of a user chain.</p>
</li>
<li>
<p><strong>Validator</strong>: Validators run the servers that allow users to download and
create blocks. They validate, execute and cryptographically certify the blocks
of all the chains.</p>
</li>
<li>
<p><strong>View</strong>: Views are like an Object-Relational Mapping (ORM) for mapping
complex types onto key-value stores. Views group complex state changes into a
set of elementary operations and commit them atomically. They are full or
partial in-memory representations of complex types saved on disk in a
key-value store</p>
</li>
<li>
<p><strong>Wallet</strong>: A file containing a user's public and private keys along with
configuration and information regarding the chains they own.</p>
</li>
<li>
<p><strong>WebAssembly (Wasm)</strong>: A binary compilation target and instruction format
that runs on a stack-based VM. Linera applications are compiled to Wasm and
run on Wasm VMs inside validators and clients.</p>
</li>
<li>
<p><strong>Web3</strong>: A natural evolution of the internet focusing on decentralization by
leveraging blockchains and smart contracts.</p>
</li>
<li>
<p><strong>Worker</strong>: A process which runs a subset of all microchains on a given
validator. This corresponds directly to a logical <em>shard</em>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="videos"><a class="header" href="#videos">Videos</a></h1>
<p>We're consistently improving the SDK and creating new material. We recorded the
following tutorial videos for the Linera Developer Summer School 2023:</p>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=Zr6BWodQ0sI">Build and deploy your first applications</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=Aq9jCeEl02k">Add testing, logging, and more to your app</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=5M5Ju35AnPE">Use cross-application calls to call other apps</a></p>
</li>
</ul>
<p><em>Happy viewing!</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="custom.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
