<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linera Developer Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">3.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/installation.html"><strong aria-hidden="true">3.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="getting_started/first_app.html"><strong aria-hidden="true">3.2.</strong> Your First App</a></li></ol></li><li class="chapter-item expanded "><a href="core_concepts.html"><strong aria-hidden="true">4.</strong> Core Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core_concepts/micro_chains.html"><strong aria-hidden="true">4.1.</strong> Microchains</a></li><li class="chapter-item expanded "><a href="core_concepts/wallet.html"><strong aria-hidden="true">4.2.</strong> The Wallet</a></li><li class="chapter-item expanded "><a href="core_concepts/validators.html"><strong aria-hidden="true">4.3.</strong> Validators</a></li><li class="chapter-item expanded "><a href="core_concepts/applications.html"><strong aria-hidden="true">4.4.</strong> Applications</a></li><li class="chapter-item expanded "><a href="core_concepts/sdk.html"><strong aria-hidden="true">4.5.</strong> Linera SDK</a></li></ol></li><li class="chapter-item expanded "><a href="advanced.html"><strong aria-hidden="true">5.</strong> Advanced Topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced_topics/execution_model.html"><strong aria-hidden="true">5.1.</strong> Execution Model</a></li><li class="chapter-item expanded "><a href="advanced_topics/views.html"><strong aria-hidden="true">5.2.</strong> Views</a></li><li class="chapter-item expanded "><a href="advanced_topics/block_creation.html"><strong aria-hidden="true">5.3.</strong> Creating New Blocks</a></li></ol></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">6.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/hello_world.html"><strong aria-hidden="true">6.1.</strong> Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">7.</strong> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linera Developer Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the developer documentation of Linera, an integrated multi-chain decentralized
protocol designed for highly-scalable web3 applications.</p>
<p>Please note that the Linera protocol is currently under active development. This
documentation is intended for developers who wish to learn more about Linera and its
programming model by building applications on top of the current Software Development Kit
(SDK).</p>
<p>We assume that you have a good understanding of blockchain technology, decentralized
applications, and smart contract development. We will provide detailed guides and examples
to help you build, test, and deploy your demo applications on your machine in a local
instance of the Linera protocol.</p>
<p>We encourage you to join our community and get involved in the development of the Linera
ecosystem. You can find more information on our website and social media channels. Let's
get started!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Linera is a decentralized infrastructure optimized for web3 applications that require processing high volumes of time-sensitive transactions created by many users in parallel.</p>
<p>The core idea of the Linera protocol is to give each user a lightweight blockchain, called a <em>microchain</em>, and to run all the microchains in parallel in a single set of validators.</p>
<h2 id="how-does-it-work"><a class="header" href="#how-does-it-work">How does it work?</a></h2>
<p>Each Linera user <em>owns</em> one or several microchains. Concretely, the <em>owner</em> of a chain chooses when to add a new block in the chain and what goes inside the block. Users typically add new blocks to their chains to process <em>incoming messages</em> or to execute secure <em>operations</em> on their accounts, for instance to transfer assets to another user.</p>
<p>Importantly, validators ensure that new blocks are <em>valid</em>, that is, can be safely executed according to the rules of the infrastructure. For instance, a block initiating a transfer from the wrong account or from an account with insufficient funds will be rejected.</p>
<p>Linera applications are meant to be multi-chain: once published and initialized, applications are deployed automatically to the chains where they are needed. To coordinate the state of an application across chains, Linera provides developers with the ability to exchange cheap and efficient cross-chain asynchronous messages. <!-- Incoming messages from another chains are first placed into an inbox. They are executed later when they are picked in a block of the receiving chain. -->
Inside a chain, applications may compose arbitrarily using synchronous function calls.</p>
<h2 id="how-does-linera-compare-to-existing-multi-chain-infrastructure"><a class="header" href="#how-does-linera-compare-to-existing-multi-chain-infrastructure">How does Linera compare to existing multi-chain infrastructure?</a></h2>
<p>Linera is the first infrastructure designed to support an arbitrary number of lightweight user chains.</p>
<p>In existing multi-chain infrastructures, each chain runs a full blockchain protocol in a separate set of validators. Creating a new chain or exchanging messages between chains is expensive. As a result, the total number of chains is generally limited. Some chains may be specialized to a given use case: these are called &quot;app chains&quot;.</p>
<p>In contrast, Linera is optimized for a large number of user chains:</p>
<ul>
<li>
<p>Users only create blocks in their chain when needed;</p>
</li>
<li>
<p>Creating a microchain does not require onboarding validators;</p>
</li>
<li>
<p>Microchains communicate efficiently using the internal networks of validators;</p>
</li>
<li>
<p>Validators are internally sharded (like a regular web service) and may adjust their capacity elastically by adding or removing internal workers.</p>
</li>
</ul>
<!--Linera integrates many chains in a unique set of validators, which greatly facilitates cross-chain communication. The execution model of Linera is designed to be language-agnostic and developer-friendly, and Linera applications are composable and multi-chain. Linera also relies on delegated proof of stake (DPoS) for security and supports regularly changing sets of validators. Microchains are designed to be auditable independently, allowing for distributed audits by the community.-->
<h2 id="why-build-on-top-of-linera"><a class="header" href="#why-build-on-top-of-linera">Why build on top of Linera?</a></h2>
<p>We believe that many high-value use cases are currently out of reach of existing web3 infrastructure because of the challenges of serving many active users simultaneously without degrading user experience. High-value use cases
that require processing time-sensitive transactions created by many simultaneous users include:</p>
<ul>
<li>
<p>real-time micro-payments and micro-rewards,</p>
</li>
<li>
<p>social data feeds,</p>
</li>
<li>
<p>marketplaces for software (e.g. based on a decentralized software repository),</p>
</li>
<li>
<p>marketplaces for AI.</p>
</li>
</ul>
<p>Lightweight user chains are instrumental in providing elastic scalability but they have other benefits as well. Because user chains have fewer blocks than traditional blockchain, we intend to embed the full-nodes of user chains in user wallets, notably browser extensions and mobile devices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Linera's SDK is a development kit that enables developers to build decentralized applications on top of the Linera protocol. It includes tools, libraries, and documentation to help developers write, test, and deploy smart contracts, as well as front-end applications.</p>
<p>The SDK includes the following components:</p>
<ul>
<li>
<p>Linera Core: The core blockchain protocol that handles consensus, transaction processing, and state management. The Linera Core is responsible for maintaining the integrity and security of the network.</p>
</li>
<li>
<p>Smart Contract Language: Linera supports smart contracts written in Rust, AssemblyScript, and other languages that can compile to WebAssembly.</p>
</li>
<li>
<p>Development Tools: The SDK includes tools for developing, testing, and deploying smart contracts, including a development environment, a command-line interface (CLI), and a web-based user interface.</p>
</li>
<li>
<p>Developer Documentation: The SDK includes comprehensive documentation for developers, including tutorials, code samples, and API reference documentation.</p>
</li>
</ul>
<h2 id="getting-started-with-lineras-sdk"><a class="header" href="#getting-started-with-lineras-sdk">Getting Started with Linera's SDK</a></h2>
<p>To get started with Linera's SDK, you will need to install the Linera CLI and set up a local development environment. The Linera CLI is a command-line tool that allows you to interact with the Linera protocol, deploy contracts, and manage your local node.</p>
<p>Once you have installed the Linera CLI and set up your development environment, you can start building smart contracts and front-end applications using the tools and libraries provided by the SDK.</p>
<p>To learn more about how to get started with Linera's SDK, check out the documentation and tutorials provided on our website. You can also join our community and get help from other developers on our Discord channel.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This section is about installing Linera and running it from source.</p>
<h2 id="os-support"><a class="header" href="#os-support">OS Support</a></h2>
<p>The Linera client and validators currently run as a set of native binaries. For this reason there is a certain dependence on the underlying operating system. Below is a matrix of supported operating systems.</p>
<div class="table-wrapper"><table><thead><tr><th>Mac OS (M1 / M2)</th><th>Mac OS (x86)</th><th>Linux x86 64-bit</th><th>Windows</th></tr></thead><tbody>
<tr><td>✓ Working</td><td>✓ Working</td><td>✓ Working</td><td>? Untested</td></tr>
</tbody></table>
</div>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>To install Linera you will need to download the source from <a href="https://github.com/linera-io/linera-protocol">GitHub</a>. If you do not have access to the repository, reach out to the team to request access.</p>
<p>To clone the repository run:</p>
<pre><code class="language-bash">git clone git@github.com:linera-io/linera-protocol.git
</code></pre>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>To install Linera from scratch, you will require the following dependencies:</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Rust + wasm32-unknown-unknown target</a></li>
<li><a href="https://grpc.io/docs/protoc-installation/">protoc</a></li>
</ul>
<p>For OS specific installation instructions see the installation section on <a href="https://github.com/linera-io/linera-protocol/blob/main/INSTALL.md">GitHub</a>.</p>
<h2 id="checking-your-installation"><a class="header" href="#checking-your-installation">Checking your Installation</a></h2>
<p>Running <code>cargo build</code> at the root of the repository will build all requisite binaries in the workspace.</p>
<p>If <code>cargo build</code> fails, reach out to the team to help troubleshoot your issue or <a href="https://github.com/linera-io/linera-protocol/issues/new">create an issue</a> on GitHub.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-app"><a class="header" href="#your-first-app">Your First App</a></h1>
<p>This section is about deploying your first application from scratch.
It is assumed that you've already cloned the Linera repository and have managed
to successfully <code>cargo build</code> the workspace.</p>
<p>By the end of this section, you'll have a working application running on your
<a href="getting_started/../core_concepts/micro_chains.html">microchain</a>.</p>
<h2 id="starting-the-local-network"><a class="header" href="#starting-the-local-network">Starting the local network</a></h2>
<p>The first step is to start your local development network.
The local development network consists of 4 <a href="getting_started/../core_concepts/validators.html">validators</a>, each
of which consist of an ingress proxy and 4 workers or shards.</p>
<p>To start your local network, navigate to the root of the <code>linera-protocol</code>
repository and run the following command:</p>
<pre><code class="language-bash">./scripts/run_local.sh
</code></pre>
<p>you will the see the names of the 4 validators running in your local network,
something like:</p>
<pre><code class="language-bash">$ ./scripts/run_local.sh
    Finished dev [unoptimized + debuginfo] target(s) in 0.13s
5b611b86cc1f54f73a4abfb4a2167c7327cc85a74cb2a5502431f67b554850b4
f65a585f05852f0610e2460a99c23faa3969f3cfce8a519f843a793dbfb4cb84
abfbf26c6f45955067f60de0317816454dbd54459dc773f185fbcaf8c72d5041
140f3259cae9ea2a3b50cbcba2495661aea42641ef44751dec0a29b192ccf32f

</code></pre>
<blockquote>
<p>The local network is running on operating system network ports, taking a total
of 20 ports to run locally. These ports are in the range P &gt; 9000 however
there
may be a collision, in which case you may want to configure the port numbers
in
the <code>configuration/</code> directory.</p>
</blockquote>
<p>The <code>run_local.sh</code> script also initialises a test wallet for you, but more on
that later.</p>
<h2 id="interacting-with-the-network"><a class="header" href="#interacting-with-the-network">Interacting with the network</a></h2>
<p>The main way of interacting with the network and deploying applications, is
using your wallet. The wallet was compiled as a result of running <code>cargo build</code>
in the previous section and can be found under <code>target/debug/client</code>.</p>
<p>Check that you have your wallet, and it can communicate with the network by
first navigating to <code>target/debug</code> and then running a command to synchronize the
balance for
your <a href="getting_started/../core_concepts/wallet.html">default chain</a> with the rest of the network.</p>
<pre><code class="language-bash">cd target/debug &amp;&amp; ./client --wallet wallet.json --genesis genesis.json sync_balance
</code></pre>
<p>You should see an output of <code>10</code>. If you're curious why we're passing all these
files to the client, we'll get to that in the <a href="getting_started/../core_concepts/wallet.html">wallet section</a>.</p>
<h2 id="building-and-example-application"><a class="header" href="#building-and-example-application">Building and example Application</a></h2>
<p>Applications running on Linera are simply <a href="https://webassembly.org/">Wasm</a>
bytecode. Each Linera validator and client has a built-in Wasm virtual machine
which can execute bytecode, all we have to do is build and publish the app on
the network.</p>
<p>We'll look at the anatomy of an application in
a <a href="getting_started/../core_concepts/applications.html">later section</a> but for now we want to compile one of the
example Linera applications which can be found in the <code>linera-examples/</code>
subdirectory.</p>
<p>To do that, navigate to one of the example applications and compile it (the
compilation target is set to <code>wasm32_unknown_unknown</code> by default)</p>
<pre><code>cd linera-examples/counter-graphql &amp;&amp; cargo build --release
</code></pre>
<h2 id="publishing-your-application"><a class="header" href="#publishing-your-application">Publishing your Application</a></h2>
<p>We can publish our compiled application to our local network by using
the <code>client</code>. To do that, navigate back to <code>./target/debug</code>.</p>
<p>To deploy the application we can use the <code>publish</code> command and provide:</p>
<ol>
<li>The location of the contract bytecode</li>
<li>The location of the service bytecode</li>
<li>The hex encoded initialization arguments</li>
</ol>
<pre><code class="language-bash">./client --storage rocksdb:client.db --wallet wallet.json --genesis genesis.json --max-pending-messages 10000 publish \
    ../../linera-examples/target/wasm32-unknown-unknown/release/counter_graphql_contract.wasm \
    ../../linera-examples/target/wasm32-unknown-unknown/release/counter_graphql_service.wasm \
    35
</code></pre>
<p>Congratulations! You've published your first application on Linera!</p>
<h2 id="querying-your-application"><a class="header" href="#querying-your-application">Querying your Application</a></h2>
<p>Now that we've published our application on the network, let's query it to get
the current counter value. To interact with an application on the network, we
need to use the client running in 'service' mode. This will expose a bunch of
APIs locally which we can use to interact with applications on the network.</p>
<p>To run the client in service mode, make sure you're in <code>./target/debug</code> and run:</p>
<pre><code class="language-bash">./client --storage rocksdb:client.db --wallet wallet.json --genesis genesis.json --max-pending-messages 10000 service
</code></pre>
<p>// todo add graphiql image here</p>
<p>Navigate to <code>http://localhost:8080</code> in your browser to access the GraphiQL, the
GraphQL IDE. We'll look at this in more detail in
a <a href="getting_started/../core_concepts/wallet.html#graphql">future section</a>; for now, list the applications deployed on your
local network by running:</p>
<pre><code class="language-gql">query {
  applications {
    id
    description
    link
  }
}
</code></pre>
<p>Since we've only deployed one application, the results returned have a single
entry.</p>
<p>At the bottom of the returned JSON there is a field called <code>link</code>, to interact
with your deployed application copy and past the link into a new browser tab.
Finally, to query the counter value of our deployed application, run:</p>
<pre><code class="language-gql">query {
  value
}
</code></pre>
<p>This will return a value of <code>35</code>, which is the initialisation argument we
specified when deploying our application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microchains"><a class="header" href="#microchains">Microchains</a></h1>
<p>This section provides an introduction to microchains - the main building block
of the Linera Protocol. For a more formal treatment of microchains, refer to
the <a href="https://static1.squarespace.com/static/62d6e9b8bf6051136f934527/t/63a0b9041c1f491f5b3a9d30/1671477510830/Linera_whitepaper_v1.pdf">whitepaper</a>.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>A microchain is a specialized type of blockchain designed to address the
limitations of traditional blockchains by offering predictable performance,
security, and responsiveness on a large scale. Unlike regular blockchains,
microchains allow users to manage the production of blocks in their own chains
for optimal performance.</p>
<p>They separate the role of proposing new blocks from validating them, providing
more flexibility and configurability. Microchains can
be single-owner, permissioned, or public, depending on who is authorized to
propose blocks. They can also create new microchains, transfer control to other
users, and deactivate when needed.</p>
<h2 id="cross-chain-messaging"><a class="header" href="#cross-chain-messaging">Cross-Chain Messaging</a></h2>
<p>In traditional blockchains, like the original Nakamoto blockchain found in
Bitcoin, the entire state transition of the system in the form of a list of
transactions, is present in each block. Since microchains have state which is
segregated from each other, a new mechanism is required for chains to
communicate with one another.</p>
<p>Cross-chain messaging is a way for different blockchains or microchains to
communicate with each other asynchronously. This method allows applications and
data to be distributed across multiple chains for better scalability. When an
application in one chain wishes to send a message to another chain, a cross-chain request
is created. These requests are implemented using remote procedure calls (RPCs)
within the validators' internal network, ensuring that each request is executed
only once.</p>
<p>Instead of immediately modifying the target chain, messages are placed first in the target
chain's <strong>inbox</strong>. When the owner(s) of the target chain creates its next block in the
future, it may reference a selection of messages taken from the current inbox in the new
block. This executes the selected messages and applies their effects to the chain state.</p>
<p>Below is an example set of chains sending asynchronous messages to each other
over consecutive blocks.</p>
<pre><code>                               ┌───┐     ┌───┐     ┌───┐
                       Chain A │   ├────►│   ├────►│   │
                               └───┘     └───┘     └───┘
                                                     ▲
                                           ┌─────────┘
                                           │
                               ┌───┐     ┌─┴─┐     ┌───┐
                       Chain B │   ├────►│   ├────►│   │
                               └───┘     └─┬─┘     └───┘
                                           │         ▲
                                           │         │
                                           ▼         │
                               ┌───┐     ┌───┐     ┌─┴─┐
                       Chain C │   ├────►│   ├────►│   │
                               └───┘     └───┘     └───┘
</code></pre>
<p>The Linera protocol allows receivers to discard messages but not to change the ordering of
selected messages inside the communication queue between two chains. If a selected message
fails to execute, it is skipped during the execution of the receiver's block. The current
implementation of the Linera client always selects as many messages as possible from
inboxes, and never discards messages.</p>
<h2 id="chain-ownership-semantics"><a class="header" href="#chain-ownership-semantics">Chain Ownership Semantics</a></h2>
<p>Linera currently supports single owner chains. However, microchains can create
new microchains for other users, and control of a chain can be transferred to
another user by changing the owner id. A chain is permanently deactivated when
its owner id is set to <code>None</code>.</p>
<p>For more detail and examples on how to open and close chains, see the wallet
section on <a href="core_concepts/wallet.html#opening-a-chain">chain management</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-wallet"><a class="header" href="#the-wallet">The Wallet</a></h1>
<p>The Linera Wallet is the main way to interact with the network. Like most
wallets, the Linera Wallet holds user private and public keys. Unlike most
wallets, the Linera Wallet also acts as a partial node, executing blocks for
chains owned by a user.</p>
<p>The state of the wallet lives in <code>wallet.json</code>, while the state of the chains
running on your local partial node are stored in <code>client.db</code>.</p>
<h2 id="chain-management"><a class="header" href="#chain-management">Chain Management</a></h2>
<p>User chains are managed explicitly via the wallet.</p>
<h3 id="listing-chains"><a class="header" href="#listing-chains">Listing Chains</a></h3>
<p>To see the chains owned by your wallet, you can use the <code>show</code> command:</p>
<pre><code class="language-bash">$ ./client --storage rocksdb:client.db  --wallet wallet.json --genesis genesis.json wallet show
╭──────────────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────────────────────────────────────╮
│ Chain Id                                                         ┆ Latest Block                                                                         │
╞══════════════════════════════════════════════════════════════════╪══════════════════════════════════════════════════════════════════════════════════════╡
│ 668774d6f49d0426f610ad0bfa22d2a06f5f5b7b5c045b84a26286ba6bce93b4 ┆ Public Key:         3812c2bf764e905a3b130a754e7709fe2fc725c0ee346cb15d6d261e4f30b8f1 │
│                                                                  ┆ Owner:              c9a538585667076981abfe99902bac9f4be93714854281b652d07bb6d444cb76 │
│                                                                  ┆ Block Hash:         -                                                                │
│                                                                  ┆ Timestamp:          2023-04-10 13:52:20.820840                                       │
│                                                                  ┆ Next Block Height:  0                                                                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 91c7b394ef500cd000e365807b770d5b76a6e8c9c2f2af8e58c205e521b5f646 ┆ Public Key:         29c19718a26cb0d5c1d28102a2836442f53e3184f33b619ff653447280ccba1a │
│                                                                  ┆ Owner:              efe0f66451f2f15c33a409dfecdf76941cf1e215c5482d632c84a2573a1474e8 │
│                                                                  ┆ Block Hash:         51605cad3f6a210183ac99f7f6ef507d0870d0c3a3858058034cfc0e3e541c13 │
│                                                                  ┆ Timestamp:          2023-04-10 13:52:21.885221                                       │
│                                                                  ┆ Next Block Height:  1                                                                │
╰──────────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────────────────────╯

</code></pre>
<p>Each row represents a chain owned by the wallet. On the left is the unique
identifier on the chain, and on the right is metadata for that chain associated
with the latest block.</p>
<h3 id="default-chain"><a class="header" href="#default-chain">Default Chain</a></h3>
<p>Each wallet has a default chain. Since wallets can hold multiple chains, a
default chain removes ambiguity in which chain is selected when performing an
operation.</p>
<p>The default chain is set initially, when the first chain is added to the wallet.
You can check the default chain for your wallet by running :</p>
<pre><code class="language-bash">$ ./client --storage rocksdb:client.db --wallet wallet.json --genesis genesis.json wallet show
</code></pre>
<p>The Chain Id which is in green text instead of white text is your default chain.</p>
<p>To change the default chain for you wallet, user the <code>set-default</code> command:</p>
<pre><code class="language-bash">$ ./client --storage rocksdb:client.db --wallet wallet.json --genesis genesis.json wallet set-default &lt;chain-id&gt;
</code></pre>
<h3 id="opening-a-chain"><a class="header" href="#opening-a-chain">Opening a Chain</a></h3>
<p>The Linera protocol defines semantics for how new chains are created, we call
this 'opening a chain'. A chain cannot be opened in a vacuum, it needs to be
created by an existing chain on the network. In the future, one of the Linera
public chains will open chains for new users - but for now an existing
single-chain owner is required to open a chain for a new wallet on the network.</p>
<h4 id="open-a-chain-for-your-own-wallet"><a class="header" href="#open-a-chain-for-your-own-wallet">Open a Chain for your own wallet</a></h4>
<p>To open a chain for your own wallet, you can use the <code>open_chain</code> command:</p>
<pre><code class="language-bash">$ ./client --storage rocksdb:client.db  --wallet wallet.json --genesis genesis.json open_chain
</code></pre>
<p>This will create a new chain (using the wallet's default chain) and add it to
the wallet. Use the <code>wallet show</code> command to see your existing chains.</p>
<h4 id="open-a-chain-for-another-wallet"><a class="header" href="#open-a-chain-for-another-wallet">Open a Chain for another wallet</a></h4>
<p>Opening a chain for another <code>wallet</code> (let's call it <code>wallet2</code>) requires an extra
two
steps.</p>
<p>First <code>wallet2</code> must create an unassigned keypair. The public part of that
keypair
is then sent to the <code>wallet</code> who is the chain creator.</p>
<pre><code class="language-bash">$ ./client --wallet wallet2.json --genesis genesis.json keygen
6443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c914088888 # this is the public key for the unassigned keypair
</code></pre>
<p>Next, using the public key, <code>wallet</code> can open a chain for <code>wallet2</code>.</p>
<pre><code class="language-bash">./client --wallet wallet.json --genesis genesis.json open_chain --to-owner 6443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c914088888
21afead36b9abfe5b0556c955f87cd167e2271eaa301546ca579be516db6eda3
91c7b394ef500cd000e365807b770d5b76a6e8c9c2f2af8e58c205e521b5f6460000000000000000000100000221afead36b9abfe5b0556c955f87cd167e2271eaa301546ca579be516db6eda36443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c91408888891c7b394ef500cd000e365807b770d5b76a6e8c9c2f2af8e58c205e521b5f64600000000000000000100000000000000000403f5447c1953dd2d4367462bf5485a08f9b89ecf9e2fc37b4c04cda0766763aa13677270633a3132372e302e302e313a39333030010000000000000034537eb025224f15bbc763ebc90431277e20923acfdc6fd2e0c3e2fabc26849313677270633a3132372e302e302e313a3932303001000000000000008e45fae6f0030f195b5818fdd7c4656da8a40c3401a248ecde6a6c0a8caf81a413677270633a3132372e302e302e313a393430300100000000000000a093522fb18888c54c3c3e9c2e808ee08d9aebc8fc8a8a42e751c0399cffb4ca13677270633a3132372e302e302e313a3931303001000000000000000400000000000000030000000000000002000000000000000300000000000000c5f4299a00f9050001cd127942d23e32ab5137a9ea07edd4db726da61affe4b7cdcdf85d71ff898f3d01b2e90cb542d342e8fc1f5b7e9ed9abbc6b04c9f08f234130ed346f7357076d2602000021afead36b9abfe5b0556c955f87cd167e2271eaa301546ca579be516db6eda300000221afead36b9abfe5b0556c955f87cd167e2271eaa301546ca579be516db6eda36443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c91408888891c7b394ef500cd000e365807b770d5b76a6e8c9c2f2af8e58c205e521b5f64600000000000000000100000000000000000403f5447c1953dd2d4367462bf5485a08f9b89ecf9e2fc37b4c04cda0766763aa13677270633a3132372e302e302e313a39333030010000000000000034537eb025224f15bbc763ebc90431277e20923acfdc6fd2e0c3e2fabc26849313677270633a3132372e302e302e313a3932303001000000000000008e45fae6f0030f195b5818fdd7c4656da8a40c3401a248ecde6a6c0a8caf81a413677270633a3132372e302e302e313a393430300100000000000000a093522fb18888c54c3c3e9c2e808ee08d9aebc8fc8a8a42e751c0399cffb4ca13677270633a3132372e302e302e313a393130300100000000000000040000000000000003000000000000000200000000000000000091c7b394ef500cd000e365807b770d5b76a6e8c9c2f2af8e58c205e521b5f64600000421afead36b9abfe5b0556c955f87cd167e2271eaa301546ca579be516db6eda391c7b394ef500cd000e365807b770d5b76a6e8c9c2f2af8e58c205e521b5f64601008095a889f7025d24dffccb5f9700439efd671de5dd453f9d2432ab73e6602613010334537eb025224f15bbc763ebc90431277e20923acfdc6fd2e0c3e2fabc2684938942c4b9c4efec2ca802d3841c5936cf1c7670794be06f4789e411ea3dd5398ca66a69630e9d0e7e3a5429e60a4332a3d927cbc22758bffe3784a7793b476903a093522fb18888c54c3c3e9c2e808ee08d9aebc8fc8a8a42e751c0399cffb4ca760f4f9c51ee0440cb6b26ca8d2e13a8265defe240c7bcb6d7c4fcc4532f36634b80ca3690f1d6c8c08a8befbb2c0ef1bd68a8b88fdef65aab973d61a31e93068e45fae6f0030f195b5818fdd7c4656da8a40c3401a248ecde6a6c0a8caf81a4138630adeca4b0b44f9904f95510048387177d16260207143dccf1946788ac7b491bbcd60d0d18f18acfed6138afbe45e0b5bea67e000da6e81facbcf0d62407
</code></pre>
<p>The first line is the Chain Id of the newly created chain. The second line is
the operation certificate.</p>
<p>Finally, to add the chain to <code>wallet2</code> for the given unassigned key we use
the <code>assign</code> command:</p>
<pre><code class="language-bash"> ./client --wallet wallet2.json --genesis genesis.json assign --key 6443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c914088888 --chain 21afead36b9abfe5b0556c955f87cd167e2271eaa301546ca579be516db6eda3 --certificate 91c7b394ef500cd000e365807b770d5b76a6e8c9c2f2af8e58c205e521b5f6460000000000000000000100000221afead36b9abfe5b0556c955f87cd167e2271eaa301546ca579be516db6eda36443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c91408888891c7b394ef500cd000e365807b770d5b76a6e8c9c2f2af8e58c205e521b5f64600000000000000000100000000000000000403f5447c1953dd2d4367462bf5485a08f9b89ecf9e2fc37b4c04cda0766763aa13677270633a3132372e302e302e313a39333030010000000000000034537eb025224f15bbc763ebc90431277e20923acfdc6fd2e0c3e2fabc26849313677270633a3132372e302e302e313a3932303001000000000000008e45fae6f0030f195b5818fdd7c4656da8a40c3401a248ecde6a6c0a8caf81a413677270633a3132372e302e302e313a393430300100000000000000a093522fb18888c54c3c3e9c2e808ee08d9aebc8fc8a8a42e751c0399cffb4ca13677270633a3132372e302e302e313a3931303001000000000000000400000000000000030000000000000002000000000000000300000000000000c5f4299a00f9050001cd127942d23e32ab5137a9ea07edd4db726da61affe4b7cdcdf85d71ff898f3d01b2e90cb542d342e8fc1f5b7e9ed9abbc6b04c9f08f234130ed346f7357076d2602000021afead36b9abfe5b0556c955f87cd167e2271eaa301546ca579be516db6eda300000221afead36b9abfe5b0556c955f87cd167e2271eaa301546ca579be516db6eda36443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c91408888891c7b394ef500cd000e365807b770d5b76a6e8c9c2f2af8e58c205e521b5f64600000000000000000100000000000000000403f5447c1953dd2d4367462bf5485a08f9b89ecf9e2fc37b4c04cda0766763aa13677270633a3132372e302e302e313a39333030010000000000000034537eb025224f15bbc763ebc90431277e20923acfdc6fd2e0c3e2fabc26849313677270633a3132372e302e302e313a3932303001000000000000008e45fae6f0030f195b5818fdd7c4656da8a40c3401a248ecde6a6c0a8caf81a413677270633a3132372e302e302e313a393430300100000000000000a093522fb18888c54c3c3e9c2e808ee08d9aebc8fc8a8a42e751c0399cffb4ca13677270633a3132372e302e302e313a393130300100000000000000040000000000000003000000000000000200000000000000000091c7b394ef500cd000e365807b770d5b76a6e8c9c2f2af8e58c205e521b5f64600000421afead36b9abfe5b0556c955f87cd167e2271eaa301546ca579be516db6eda391c7b394ef500cd000e365807b770d5b76a6e8c9c2f2af8e58c205e521b5f64601008095a889f7025d24dffccb5f9700439efd671de5dd453f9d2432ab73e6602613010334537eb025224f15bbc763ebc90431277e20923acfdc6fd2e0c3e2fabc2684938942c4b9c4efec2ca802d3841c5936cf1c7670794be06f4789e411ea3dd5398ca66a69630e9d0e7e3a5429e60a4332a3d927cbc22758bffe3784a7793b476903a093522fb18888c54c3c3e9c2e808ee08d9aebc8fc8a8a42e751c0399cffb4ca760f4f9c51ee0440cb6b26ca8d2e13a8265defe240c7bcb6d7c4fcc4532f36634b80ca3690f1d6c8c08a8befbb2c0ef1bd68a8b88fdef65aab973d61a31e93068e45fae6f0030f195b5818fdd7c4656da8a40c3401a248ecde6a6c0a8caf81a4138630adeca4b0b44f9904f95510048387177d16260207143dccf1946788ac7b491bbcd60d0d18f18acfed6138afbe45e0b5bea67e000da6e81facbcf0d62407
</code></pre>
<h2 id="node-service"><a class="header" href="#node-service">Node Service</a></h2>
<p>So far we've seen how to interact with the wallet while treating it as a binary
in your terminal. However, the wallet also acts as a partial node which:</p>
<ol>
<li>Executes blocks</li>
<li>Exposes an GraphQL API and IDE for dynamically interacting with applications
and the system</li>
<li>Listens for notifications from validators and automatically updates local
chains.</li>
</ol>
<p>To interact with the node service, simply run the wallet in <code>service</code> mode:</p>
<pre><code class="language-bash">./client --storage rocksdb:client.db --wallet wallet.json --genesis genesis.json --max-pending-messages 10000 service
</code></pre>
<p>This will run the node service on port 8080 by default (this can be overridden
using the <code>--port</code> flag).</p>
<h3 id="a-note-on-graphql"><a class="header" href="#a-note-on-graphql">A Note on GraphQL</a></h3>
<p>Linera uses GraphQL as the primary query language for interfacing with different
parts of the system. GraphQL is a query language developed by Facebook which
enables client to craft queries such that they receive exactly what they want
and nothing more.</p>
<p>GraphQL is used extensively during application development, especially to query
the state of an application from a front-end for example.</p>
<p>To learn more about GraphQL check out
the <a href="https://graphql.org/learn/">official docs</a>.</p>
<h3 id="graphiql-ide"><a class="header" href="#graphiql-ide">GraphiQL IDE</a></h3>
<p>Conveniently, the node service exposes a GraphQL IDE called GraphiQL. To use
GraphiQL start the node service and navigate to <code>localhost:8080/</code>.</p>
<p>Using the schema explorer on the left of the GraphiQL IDE you can dynamically
explore the state of the system and your applications.</p>
<p><img src="core_concepts/graphiql.png" alt="graphiql.png" /></p>
<h2 id="graphql-api"><a class="header" href="#graphql-api">GraphQL API</a></h2>
<p>The node service also exposes a GraphQL API which corresponds to the set of
system operations. You can explore the full set of operations by using the
aforementioned schema explorer under <code>MutationRoot</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validators"><a class="header" href="#validators">Validators</a></h1>
<p>The validators run servers that allow users to download and create blocks. They validate,
execute and cryptographically certify blocks on all microchains. That means every single
chain is backed by the full set of validators, and has the same level of security.</p>
<p>Concretely, they guarantee that:</p>
<ul>
<li>Each block is valid, i.e. it has the correct format, its operations are allowed, the
received effects are in the correct order, and e.g. the balance was correctly computed.</li>
<li>Every effect received by one chain was actually sent by another chain.</li>
<li>If one block on a particular height is certified, no other block on the same height is.</li>
</ul>
<p>To undermine these guarantees, at least one third of the validators (weighted by their
stake) would need to cheat---in a detectable way! (Staking is not yet implemented, but in
the future, malicious validators would forfeit their stakes.)</p>
<p>Since validators do not propose blocks on most chains, they do <em>not</em> guarantee that any
particular operation or effect will eventually be executed on a chain. Instead, chain
owners decide whether and when to propose new blocks, and which operations and effects to
include.
The Linera client implementation will automatically include all incoming effects in new
blocks. The operations are the actions the chain owner explicitly adds, e.g. transfer.</p>
<h2 id="scalability"><a class="header" href="#scalability">Scalability</a></h2>
<p>Since every chain uses the same validators, adding more chains does not require adding
additional validators. Instead, it requires each individual validator to scale up and
handle the additional load.</p>
<p>That is why Linera allows the same validator to run multiple <code>server</code>
processes—<em>workers</em>—on different machines, each one processing a different subset of
the microchains. The workers communicate directly with each other whenever a chain sends
an effect to another chain.</p>
<h2 id="anatomy-of-a-validator"><a class="header" href="#anatomy-of-a-validator">Anatomy of a Validator</a></h2>
<p>To achieve scalability, Linera validators need to be horizontally scalable (sometimes
referred to as 'elastic'). To achieve this scalability, the architecture of a validator
involves splitting the chains up over multiple 'shards' or 'workers' which are
encapsulated by a single ingress/egress called the 'proxy'.</p>
<p>The validator has an internal network enabling the proxy to speak with shards and shards
with each other. Each shard is also backed by its own data store which can be scaled
independently of the rest of the validator</p>
<pre><code> example network
                     │                                           │
                     │                                           │
                     │                                           │
┌────────────────────┼────────────────────┐ ┌────────────────────┼────────────────────┐
│ validator 1        │                    │ │ validator 2        │                    │
│              ┌─────┴─────┐              │ │              ┌─────┴─────┐              │
│              │   proxy   │              │ │              │   proxy   │              │
│        ┌─────┤           ├─────┐        │ │        ┌─────┤           ├─────┐        │
│        │     └───────────┘     │        │ │        │     └───────────┘     │        │
│        │                       │        │ │        │                       │        │
│        │                       │        │ │        │                       │        │
│  ┌─────┴─────┐           ┌─────┴─────┐  │ │  ┌─────┴─────┐           ┌─────┴─────┐  │
│  │   shard   │           │   shard   │  │ │  │   shard   │           │   shard   │  │
│  │     1     │           │     2     │  │ │  │     1     │           │     2     │  │
│  └─────┬─────┘           └─────┬─────┘  │ │  └─────┬─────┘           └─────┬─────┘  │
│        │                       │        │ │        │                       │        │
│  ┌─────┴─────┐           ┌─────┴─────┐  │ │  ┌─────┴─────┐           ┌─────┴─────┐  │
│  │    db1    │           │    db2    │  │ │  │    db1    │           │    db2    │  │
│  │           │           │           │  │ │  │           │           │           │  │
│  └───────────┘           └───────────┘  │ │  └───────────┘           └───────────┘  │
│                                         │ │                                         │
└─────────────────────────────────────────┘ └─────────────────────────────────────────┘

</code></pre>
<h2 id="configuring-networks-workers-and-proxies"><a class="header" href="#configuring-networks-workers-and-proxies">Configuring Networks, Workers and Proxies</a></h2>
<p>In <a href="core_concepts/../getting_started/first_app.html">Your First App</a> we used the <code>run_local.sh</code> script
to start a local network. This should be sufficient for most usecases when you're running
a local network.</p>
<pre><code class="language-bash">./scripts/run_local.sh
</code></pre>
<p>However, it is possible to customise and configure the parameters of the network.</p>
<p><code>run_local.sh</code> uses the <code>validator_n.toml</code> file from the <code>configuration/</code> directory to configure validator number <code>n</code>.</p>
<pre><code class="language-bash">./server generate --validators configuration/validator_{1,2,3,4}.toml --committee committee.json
</code></pre>
<p>generates keys and writes them, together with the options from the TOML files, to
<code>server_1.json</code>, ..., <code>server_4.json</code>. It also stores the set of the new validators'
public keys in <code>committee.json</code>.</p>
<pre><code class="language-bash">./client --wallet wallet.json --genesis genesis.json create_genesis_config 10 --initial-funding 10 --committee committee.json
</code></pre>
<p>creates a configuration for the initial state of the network, <code>genesis.json</code>, with 10
chains, each with a balance of 10. It also creates a <code>wallet.json</code> for a client who owns
all those chains.</p>
<p>To start the newly configured network, each validator <code>n</code> must start their proxy:</p>
<pre><code class="language-bash">./proxy server_n.json &amp;
</code></pre>
<p>And all shards; for shard <code>i</code>:</p>
<pre><code class="language-bash">./server run --storage rocksdb:server_n_i.db --server server_n.json --shard i --genesis genesis.json &amp;
</code></pre>
<p>This will create a separate database file <code>server_n_i.db</code> for each shard. In a production
network, these would be running on different machines.</p>
<h2 id="changing-the-set-of-validators"><a class="header" href="#changing-the-set-of-validators">Changing the Set of Validators</a></h2>
<p>If a new validator wants to start participating, or an old one wants to leave, all chains
must be updated.</p>
<p>The system has has one designated <em>admin chain</em>, where the validators can join or leave
or, and where new <em>epochs</em> are defined. During every epoch, the set of validators is
fixed.</p>
<p>Chain owners must then create a block that receives the <code>SetCommittees</code> effect from the
admin chain, and have it certified by the old validators. Only the <em>next</em> block in their
chain will be certified by the new validator set!</p>
<p>That is why epochs are planned to change infrequently—possibly once per day or per
week—, and several subsequent epochs can overlap, so that chain owners have plenty of
time to migrate their chains.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applications"><a class="header" href="#applications">Applications</a></h1>
<p>This section is all about building applications in Linera. The Linera programming
model is designed to provide a rich ecosystem to enable developers to take advantage
of the scaling architecture of microchains.</p>
<p>Linera uses the WebAssembly VM to execute user applications. For now
the <a href="core_concepts/./sdk.html">SDK</a> used to develop Linera applications is exclusively for
the <a href="https://www.rust-lang.org/">Rust</a> programming language. This will be
covered in depth in the <a href="core_concepts/./sdk.html">next section</a>.</p>
<h2 id="the-application-deployment-lifecycle"><a class="header" href="#the-application-deployment-lifecycle">The Application Deployment Lifecycle</a></h2>
<p>Linera Applications are designed to be powerful yet re-usable. For this reason
there is a distinction between the application bytecode and an application
instance on the network.</p>
<p>Applications undergo a lifecycle transition aimed at making development easy and
flexible:</p>
<ol>
<li>The application bytecode is built from a Rust project with the <code>linera-sdk</code>
dependency.</li>
<li>The application bytecode is published to the network on a given microchain.
The bytecode location itself is then opaque to the rest of the network, the
only way to reference it is with a bytecode identifier.</li>
<li>After the bytecode is published, a user can create a new application instance
by referencing the bytecode and providing initialisation parameters. This
process returns an application identifier which can be used to reference and
interact with the application.</li>
<li>The same bytecode identifier can be used as many times is needed by as many
users are needed to create distinct applications.</li>
</ol>
<p>Happily, the application deployment lifecycle is abstracted from the user, and
an application can be published with a single command:</p>
<pre><code class="language-bash">./client --storage rocksdb:client.db --wallet wallet.json --genesis genesis.json --max-pending-messages 10000 publish &lt;contract-path&gt; &lt;service-path&gt; &lt;init-args&gt;
</code></pre>
<p>This will publish the bytecode as well as initialise the application for you.</p>
<h2 id="anatomy-of-an-application"><a class="header" href="#anatomy-of-an-application">Anatomy of an Application</a></h2>
<p>An application is broken into two major components, the 'contract' and the '
service'.</p>
<p>The contract is gas-metered (for more details,
see <a href="core_concepts/../advanced_topics/execution_model.html">execution model</a>), and is the part
of the application which executes operations and effects, make cross-application
calls and modifies the application's state. The details are covered in more
depth in the
<a href="core_concepts/./sdk.html">SDK docs</a>.</p>
<p>The service, is non-metered and read-only. It is used primarily to query the
state of an application and hydrate the presentation layer (think front-end)
with the data required for a user interface.</p>
<p>Finally, spanning both the contract and service is the Application's state in
the form of a <a href="core_concepts/./../advanced_topics/views.html">View</a>, but more on that later.</p>
<h2 id="operations-and-effects"><a class="header" href="#operations-and-effects">Operations and Effects</a></h2>
<blockquote>
<p>For this section we'll be using the example of a hypothetical 'fungible token'
application where users can send tokens to each other.</p>
</blockquote>
<p>At the system-level, interacting with an application can be done via operations
and effects.</p>
<p><strong>Operations</strong> are defined by an application developer and each
application can have a completely different set of operations. Chain owners then
actively create operations and put them in their block proposals to interact
with an application.</p>
<p>Using our hypothetical 'fungible token' application as an example, an operation
for a user to transfer funds to another user would look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// An operation.
#[derive(Deserialize, Serialize)]
pub enum Operation {
    /// A transfer from a (locally owned) account to a (possibly remote) account.
    Transfer {
        owner: AccountOwner,
        amount: Amount,
        target_account: Account,
    },
    // Meant to be extended here
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Effects</strong> are outcomes of execution (of operations or other effects).
Effects from one chain can be sent in a cross-chain message to another. Block
proposers also actively include effects in their block proposal, but unlike with
operations, they are only allowed to include them in the right order (possibly
skipping some), and only if they were actually created by another chain (or the
same chain, earlier).</p>
<p>Using our hypothetical 'fungible token' application as an example, an effect
to credit an account would look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// An effect.
#[derive(Deserialize, Serialize)]
pub enum Effect {
    Credit { owner: AccountOwner, amount: Amount },
    // Meant to be extended here
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interacting-with-an-application"><a class="header" href="#interacting-with-an-application">Interacting with an Application</a></h2>
<p>To interact with an application, we follow the same principle as interacting
with the Linera network system and we use the wallet.</p>
<p>When <a href="core_concepts/wallet.html#node-service">run in 'service' mode</a>, the wallet exposes a
GraphQL API for every application running on that chain. To interface with an
application running on a given chain, run the wallet in <code>service</code> mode for that
chain and the API for the application is then available
at <code>localhost:8080/&lt;application-id&gt;</code>.</p>
<p>Simple navigating there with your browser will open a GraphiQL interface which
enables you to graphically explore the state of your application.</p>
<h2 id="end-to-end-front-end"><a class="header" href="#end-to-end-front-end">End-to-End Front-end?</a></h2>
<h2 id="registering-an-application-across-chains"><a class="header" href="#registering-an-application-across-chains">Registering an Application across Chains</a></h2>
<p>Let us assume that User A has Chain X, and User B has Chain Y. Let us also
assume that Application 1 is deployed on Chain X.</p>
<p>User A can interact with Application 1 since it is deployed on their Chain (
Chain X), however User B cannot see Application 1 since his Chain, Chain Y has
not registered the application.</p>
<p>In order for User B to use Application 1, Application 1 <em>must</em> first make a
cross-chain request to Chain Y in order for tha application to get registered on
Chain Y. Once that is done, User B can interact with Application 1 on Chain Y.</p>
<p>If this was not the case, every chain would run every application, and we would
end up with microchains which are simply full-scale Nakamoto blockchains. This '
discovering' strategy enables Chains to only care about a finite subset of the
state of the entire network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linera-sdk"><a class="header" href="#linera-sdk">Linera SDK</a></h1>
<h2 id="linera-sdk-crate"><a class="header" href="#linera-sdk-crate">Linera SDK Crate</a></h2>
<p>The <code>linera-sdk</code> crate exposes the basic traits required to create a Linera
application.</p>
<p>This section takes you over the steps to create a full Web 3 application with a
Linera application for the back end and a React front end.</p>
<h2 id="creating-your-linera-project"><a class="header" href="#creating-your-linera-project">Creating your Linera Project</a></h2>
<h2 id="creating-the-state"><a class="header" href="#creating-the-state">Creating the State</a></h2>
<p>The <code>State</code> is the place where the data of the application is stored. For
example we can have for the application <code>FungibleToken</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Default, Deserialize, Serialize)]
pub struct FungibleToken {
    accounts: BTreeMap&lt;AccountOwner, Amount&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>If one uses the view version of the code then we will have</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(RootView)]
pub struct FungibleToken&lt;C&gt; {
    accounts: MapView&lt;C, AccountOwner, Amount&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>for which every entry of the struct has to be a view.</p>
<h2 id="creating-the-contract"><a class="header" href="#creating-the-contract">Creating the Contract</a></h2>
<p>The <code>Contract</code> is the first component of your Linera application. It can
actually change the state of the application. The <code>Contract</code> trait that
has to be implemented is the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait Contract: Sized {
    /// Message reports for application execution errors.
    type Error: Error;
    /// The desired storage backend to use to store the application's state.
    type Storage;

    /// Initializes the application on the chain that created it.
    async fn initialize(
        &amp;mut self,
        context: &amp;OperationContext,
        argument: &amp;[u8],
    ) -&gt; Result&lt;ExecutionResult, Self::Error&gt;;

    /// Applies an operation from the current block.
    async fn execute_operation(
        &amp;mut self,
        context: &amp;OperationContext,
        operation: &amp;[u8],
    ) -&gt; Result&lt;ExecutionResult, Self::Error&gt;;

    /// Applies an effect originating from a cross-chain message.
    async fn execute_effect(
        &amp;mut self,
        context: &amp;EffectContext,
        effect: &amp;[u8],
    ) -&gt; Result&lt;ExecutionResult, Self::Error&gt;;

    /// Handles a call from another application.
    async fn handle_application_call(
        &amp;mut self,
        context: &amp;CalleeContext,
        argument: &amp;[u8],
        forwarded_sessions: Vec&lt;SessionId&gt;,
    ) -&gt; Result&lt;ApplicationCallResult, Self::Error&gt;;

    /// Handles a call into a session created by this application.
    async fn handle_session_call(
        &amp;mut self,
        context: &amp;CalleeContext,
        session: Session,
        argument: &amp;[u8],
        forwarded_sessions: Vec&lt;SessionId&gt;,
    ) -&gt; Result&lt;SessionCallResult, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>This trait can be interpreted in the following way:</p>
<ul>
<li>The <code>initialize</code> is clear. This is how the application starts. It can be conceived
of a constructor. If the application depends on other application such as <code>FungibleToken</code>
then they will be typically be assigned during that initialization process.</li>
<li>The <code>execute_operation</code> is for executing operations on the same chain in which
they are received. If the state is located in another chain, then the operation
has to be transmitted by creating an effect and returning it in the <code>ExecutionResult</code>.</li>
<li>The <code>execute_effect</code> is executing the effects that have been created from other
parts of the code.</li>
<li>The <code>handle_application_call</code> is for executing operations originating from application calls.
One way to process it is by creating an effect that carry the intent.</li>
<li>The <code>handle_session_call</code> is an experimental feature that is not yet fully developed
and should not be relevant at the present time. Therefore, the authors simply need to return
a <code>Err(Error::SessionsNotSupported)</code> to indicate so.</li>
</ul>
<h2 id="creating-the-service"><a class="header" href="#creating-the-service">Creating the Service</a></h2>
<p>The <code>Service</code> is the second component of your Linera application. It is compiled
into a separate Bytecode from the contract and is run independently. It is not
metered (meaning that querying an application's service does not consume gas),
and can be thought of as a read-only view into your application.</p>
<p>Your application state can be arbitrarily complex, and most of the time you
don't
want to expose this state in its entirety to those who would like to interact
with your app. Instead, you might prefer to define a distinct set of queries
that
can be made against your application.</p>
<p>The <code>Service</code> trait is how you define the interface into your application.
The <code>Service</code> trait is defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait Service {
    /// Message reports for service execution errors.
    type Error: Error;
    /// The desired storage backend to use to read the application's state.
    type Storage;

    /// Executes a read-only query on the state of this application.
    async fn query_application(
        self: Arc&lt;Self&gt;,
        context: &amp;QueryContext,
        argument: &amp;[u8],
    ) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Let's implement <code>Service</code> for our counter application.</p>
<p>First, we want to generate the necessary boilerplate for implementing the
service WIT interface, export the necessary resource types and functions so that
the host (the process running the bytecode) can call the service. Happilly,
there is a macro to perform this code generation, so simply add the following
to <code>service.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>linera_sdk::service!(Counter&lt;ReadOnlyViewStorageContext&gt;);
<span class="boring">}</span></code></pre></pre>
<p>Notice that the Counter context is <code>ReadOnlyViewStorageContext</code>. This ensures
that the host has a read-only view on the application's state.</p>
<p>Next, we need to implement the <code>Service</code> for <code>Counter</code>. To do this we need to
define <code>Service</code>'s associated types and implement <code>query_application</code>, as well
as define the <code>Error</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
impl&lt;C&gt; Service for Counter&lt;C&gt;
    where
        C: Context + Send + Sync + Clone + 'static,
        ViewError: From&lt;C::Error&gt;,
{
    type Error = Error;
    type Storage = ViewStateStorage&lt;Self&gt;;

    async fn query_application(
        self: Arc&lt;Self&gt;,
        _context: &amp;QueryContext,
        argument: &amp;[u8],
    ) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt; {
        let graphql_request: async_graphql::Request = serde_json::from_slice(argument).map_err(|_| Error::InvalidQuery)?;
        let schema = Schema::build(self.clone(), MutationRoot {}, EmptySubscription).finish();
        let res = schema.execute(graphql_request).await;
        Ok(serde_json::to_vec(&amp;res).unwrap())
    }
}

/// An error that can occur during the contract execution.
#[derive(Debug, Error, Eq, PartialEq)]
pub enum Error {
    /// Invalid query argument; Counter application only supports a single (empty) query.
    #[error(
    &quot;Invalid query argument; Counter application only supports JSON encoded GraphQL queries&quot;
    )]
    InvalidQuery,
}
<span class="boring">}</span></code></pre></pre>
<p>Notice, that the input <code>argument</code> and returned <code>Vec&lt;u8&gt;</code> are both simple byte
arrays. Therefore, the inputs and outputs made to the service can be effectively
arbitrary. In our case, we'll be using the existing Linera GraphQL
infrastructure to make our app easy for a graphical front end to consume.</p>
<p>The final piece of the the service is the <code>MutationRoot</code>. This is a convencience
schema which is used for GraphQL introspection queries:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MutationRoot;

#[Object]
impl MutationRoot {
    #[allow(unused)]
    async fn execute_operation(&amp;self, operation: CounterOperation) -&gt; Vec&lt;u8&gt; {
        bcs::to_bytes(&amp;operation).unwrap()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We haven't included the imports in the above code; they are left as an
exercise to the reader. If you want the full source code and associated tests
check out
the <a href="https://github.com/linera-io/linera-protocol/blob/main/linera-examples/counter-graphql/src/service.rs">examples section</a>
on GitHub.</p>
<h2 id="deploying-your-application"><a class="header" href="#deploying-your-application">Deploying your Application</a></h2>
<h2 id="building-a-front-end-for-your-application"><a class="header" href="#building-a-front-end-for-your-application">Building a Front End for your Application</a></h2>
<h2 id="running-your-web-3-app"><a class="header" href="#running-your-web-3-app">Running your Web 3 App</a></h2>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="execution-model"><a class="header" href="#execution-model">Execution Model</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="views"><a class="header" href="#views">Views</a></h1>
<p>Views are a specific functionality of the Linera system that allow to have data in memory
and then write it to the database in a flush.</p>
<p>In practical terms what is provided is the following:</p>
<ul>
<li>A trait &quot;View&quot; that provides &quot;load&quot;, &quot;rollback&quot;, &quot;clear&quot;, &quot;flush&quot;, &quot;delete&quot;. The idea
is that we can do operation on the data and then flush it to the database storing them.</li>
<li>Several other traits &quot;HashableView&quot;, &quot;RootView&quot;, &quot;CryptoHashView&quot;, &quot;CryptoHashRootView&quot;
that are important for computing hash.</li>
<li>A number of standard containers: MapView, SetView, LogView, QueueView, RegisterView
that implement the View and HashableView traits.</li>
<li>Two containers CollectionView and ReentrantCollectionView that are similar to MapView but
whose values are views themselves.</li>
<li>Derive macros that allow to implement the above mentioned traits on struct data types whose
entries are views.</li>
</ul>
<p>The full documentation is available on the crate documentation with all functions having
examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="creating-new-blocks"><a class="header" href="#creating-new-blocks">Creating New Blocks</a></h2>
<p>Unlike validators in most other platforms, and unlike the workers that belong to a single
validator, Linera validators do not need to exchange messages with each other directly.
Instead, the chain owners' <code>client</code> processes make the system progress by actively
providing the required data to the validators. E.g. each command like <code>client transfer</code>,
<code>publish</code> or <code>open_chain</code> performs multiple steps to append a block containing the
token transfer, application publishing or chain creation operation:</p>
<ul>
<li>The client creates a new block containing the desired operation and new incoming
effects, if there are any. It also contains the most recent block's hash to designate
its parent. The client sends the new block to all validators.</li>
<li>The validators validate the block, i.e. check that the block satisfies the conditions
listed above, and send a cryptographic signature to the client, indicating that they
vote to append the new block. But only if they have not voted for a different block on
the same height earlier!</li>
<li>The client ideally receives a vote from every validator, but only two thirds are
required: These constitute a &quot;certificate&quot;, proving that the block was confirmed.
The client sends the certificate to every validator.</li>
<li>The validators &quot;execute&quot; the block: They update their own view of the most recent state
of the chain by applying all effects and operations, and if it generated any cross-chain
messages, they send these to the appropriate workers.</li>
</ul>
<p>To guarantee that each incoming effect in a block was actually sent by another chain,
a validator will, in the second step, only <em>vote</em> for a block, if it has already executed
the block that sent it.
However, when receiving a valid certificate for a block that receives an effect it has not
seen yet, it will accept and <em>execute</em> the block anyway: The certificate is proof that most
other validators have seen the effect, so it must be correct.</p>
<p>This procedure applies to the simplest and lowest-latency kind of chain. Clients must be
careful to never propose multiple blocks at the same height: Once two conflicting blocks
have been signed by more than a third of the validators each, it becomes impossible to
ever collect votes for one block from two thirds of the validators, and the chain is
stuck.</p>
<p>Therefore in practice, most users should use <em>shared chains</em> even if they are the only
chain owner. These have two instead of one confirmation steps. The latency is slightly
higher, but it is not possible to accidentally make a chain unextendable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>// todo, do we need this?</p>
<ul>
<li>Effect:</li>
<li>Microchain:</li>
<li>Operation:</li>
<li>Owner / Address:</li>
<li>Validator:</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
